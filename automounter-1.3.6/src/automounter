#!/bin/sh -f
#
# Copyright (c) 2008, 2009, 2010
# Dominic Fandrey <kamikaze@bsdforen.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

version=1.3.6

# AMD parameters
a="%%RUN%%/automounter.amd"
c=10
w=5
l="%%RUN%%/automounter.amd.log"
directory="%%RUN%%/automounter.amd.mnt"
map="%%RUN%%/automounter.amd.map"

# The amd map that the dynamic mounts are appended to.
static_map="%%MAP%%"

# The location of the devfs.
devfs="%%DEVFS%%"

# A file to remember for which partitions automounter has been configured.
nodes="%%TMP%%/automounter.nodes"

# A temporary file for the partitions of the last run.
oldnodes="%%RUN%%/automounter.nodes.old"

# The pid of amd.
pidfile="%%RUN%%/automounter.amd.pid"

# This is where the links will be created to access the file systems.
linkdir="%%MEDIA%%"

# This is where the folders to mount the file systems into will be created.
mountdir="%%RUN%%/automounter.mnt"

# Lock file.
lock="%%RUN%%/automounter.lock"

# Geli is inactive, set this to anything but 0 to activate it.
geli=0

# A file to remember which geli encrypted providers belong to which node.
#
# The file is in the following format:
# 	<providerName>;<mdDevice>;<keyLabel>
#
# It is expected to meet this extended regular expression: [^;]+;md[0-9]+;[^;]+
# 	providerName	is the filename of the image or device link.
#	mdDevice	is the device node of the file backed memory disk as
#			it was returned by mdconfig.
#	keyLabel	is the absolute path to the key the image was activated
#			with.
# 	
geli_nodes="%%RUN%%/automounter.geli.nodes"

# A temporary file to recognize which nodes were available during the last run.
geli_oldnodes="%%RUN%%/automounter.geli.oldnodes"

# A file to remember where we can find which keys.
#
# The format is:
#	<label>;<keyName>
geli_availablekeys="%%RUN%%/automounter.geli.keys"

# GEOM ELI encrypted images and device link location.
geli_images="%%GELI_IMAGES%%"

# GEOM ELI keys location.
geli_keys="%%GELI_KEYS%%"

# Timeout in seconds for aquiring the lock.
timeout=10

# The delay before the update command takes effect. This is necessary
# to ensure that geom knows about new labels.
update_delay=2

# The default mount options.
mount_options=rw,noatime,noexec

# Mount isos as cd9660.
iso9660=cd9660
iso9660_options=ro

# Do not try to mount devices by ID.
blacklist_nodes='*id/*'

# Dirty fusefs bug workaround.
evil_fuse=0

# Config file.
config="%%PREFIX%%/etc/automounter.conf"
if [ -e "$config" -a ! -d "$config" ]; then
	. "$config"
fi

# devfs must not end with /
devfs="${devfs%/}"

IFS='
'

#
# Removes a set of media links.
#
# @param @
#	Expects a list of labels and devices in the form:
#		[<label> <device>]*
#
rmLinks() {
	local label device

	while [ -n "$1" ]; do
		label="$1"
		device="$2"
		# Prepare for the next iteration.
		shift 2

		# Make sure this device is not mounted.
		/sbin/umount -f "$mountdir/$label" > "$devfs/null" 2>&1

		# Remove the stale label.
		echo "del label: <$label> from <$device>"
		/bin/rm "$linkdir/$label"
		/bin/rm "$linkdir/${devfs##*/}/$device"
		/bin/rmdir "$linkdir/${devfs##*/}" 2> "$devfs/null"
		/bin/rmdir "$linkdir/${label%%/*}" 2> "$devfs/null"
		/bin/rmdir "$mountdir/$label"
		/bin/rmdir "$mountdir/${label%%/*}" 2> "$devfs/null"

		# Forget keys belonging to this label.
		keys="$(echo "$keys" | grep -Fv ";$label;")"
	done
}

#
# Creates a set of media links.
#
# @param @
#	Expects a list of labels and devices in the form:
#		[<label> <device>]*
#
createLinks() {
	local label device

	while [ -n "$1" ]; do
		label="$1"
		device="$2"
		# Prepare for the next iteration.
		shift 2
		
		# Create mount hooks.
		echo "add label: <$label> from <$device>"
		/bin/mkdir -p "$mountdir/$label"

		# Inherit mount node owner from device.
		/usr/sbin/chown "$(
			/usr/bin/stat -f %u:%g "$devfs/$label" 2> /dev/null \
				|| /usr/bin/stat -f %u:%g "$devfs/$device"
		)" "$mountdir/$label"

		# Inherit permissions from device. Add the executable
		# bit if read or write are permitted.
		/bin/chmod "$(
			(
				/usr/bin/stat -f %p "$devfs/$label" \
				2> /dev/null \
					|| /usr/bin/stat -f %p "$devfs/$device"
			) | /usr/bin/sed -e 's/.//1' \
				-e 's/2/3/g' \
				-e 's/4/5/g' \
				-e 's/6/7/g'
		)" "$mountdir/$label"

		# Create the links that invoke amd.
		/bin/mkdir -p "$linkdir/$type"
		/bin/mkdir -p "$linkdir/${devfs##*/}"
		/bin/ln -s "$directory/$hash" "$linkdir/$label"
		/bin/ln -s "$directory/$hash" "$linkdir/${devfs##*/}/$device"
	done
}

#
# This function is forked by geli_update to unmount images that do not longer
# have a key available.
#
# @param 1
#	The label of the key holding file system.
# @param 2
#	The name of the geli provider to unmount.
# @param 3
#	The device the geli provider is available as.
#
geli_unmount() {
	local label name device
	label="$1"
	name="$2"
	device="$3"

	# Attempt to detach until successful or until the
	# key has returned.
	while true; do
		/bin/sleep 1
		# Skip if the key to this image has returned.
		/usr/bin/lockf "$lock" /bin/sh -c "
			if /usr/bin/grep -qFx '$label;$name' \
				'$geli_availablekeys'; then
				exit 0
			else
				/sbin/geli detach '$device' \
					2> '$devfs/null' \
					|| exit 1
				/bin/mv '$geli_nodes' \
					'$geli_oldnodes'
				/usr/bin/grep -vFx '$line' \
					'$geli_oldnodes' \
					> '$geli_nodes'
				/bin/rm '$geli_oldnodes'
				exit 2
			fi
		"
		case $? in
			0)
				# The key is back, no more
				# need to detach.
				exit 0
			;;
			1)
				# Detach failed.
				continue
			;;
			2)
				# Detach succeeded.
				echo "del encrypted provider:" \
					"<$name> as <$device>" \
					"with key from <$label>"
				break
			;;
		esac
	done
	# Update labels in a locked fashion.
	$0 update &

	# Hang around to remove the device node for the image.
	# Unless it's a device link.
	if [ -e "$geli_images/$name" ]; then
		until /sbin/mdconfig -du "$device"; do
			/bin/sleep "$w"
		done
	fi
}

#
# Updates the amd.map, the list of partitions and the mount links, if amd
# is running.
#
update() {
	local device line partitions label type options hash \
		owner mode key

	# Give geom some time to identify the label.
	/bin/sleep "$update_delay"

	# Don't do anything if amd is not running.
	# This prevents automounter from starting too early from devd.
	/bin/sync
	if [ ! -e "$pidfile" ]; then
		echo "automounter not started"
		return 0
	fi

	# Start building a new map by copying the static one.
	/bin/cp "$static_map" "$map"

	/bin/mkdir -p "$a"
	/usr/bin/touch "$nodes"
	/bin/mv "$nodes" "$oldnodes"
	/usr/bin/touch "$nodes"

	# Change the blacklists' format into something that can be used in a
	# case statement.
	devices_blacklist="$(
		echo "${blacklist_devs}" | /usr/bin/sed -E \
			-e 's/,/|/g' -e 's,([[:space:]\\]),\\\1,g'
	)"
	nodes_blacklist="$(
		echo "${blacklist_nodes}" | /usr/bin/sed -E \
			-e 's/,/|/g' -e 's,([[:space:]\\]),\\\1,g'
	)"

	# Create a list in the shape:
	#
	# device
	# label
	# --
	# device
	# label
	# --
	# ...
	partitions="$(
		/sbin/glabel list | /usr/bin/grep -A2 'Geom name: ' | \
		/usr/bin/grep -v 'Providers:' | \
		/usr/bin/sed -E -e 's/Geom name: (.*)/\1/1' \
			-e 's/.*Name: (.*)/\1/1'
	)"

	# Add new mounts.
	device=
	for line in $partitions; do
		# A line separator is encountered, prepare everything
		# for dealing with the next line.
		if [ "$line" = "--" ]; then
			device=
			continue
		fi
		
		# The current line is the device name, remember it and
		# go on to the next line.
		if [ -z "$device" ]; then
			device="$line"
			continue
		fi

		# Finally we can set up a mount.
		label="$line"

		# Check weather the device is blacklisted.
		if [ -n "$devices_blacklist" ]; then
			eval "
				case '$device' in
					$devices_blacklist)
						device=
						continue
					;;
				esac
			"
		fi

		# Check weather the partition is blacklisted.
		if [ -n "$nodes_blacklist" ]; then
			eval "
				case '$label' in
					$nodes_blacklist)
						device=
						continue
					;;
				esac
			"
		fi

		type="${label%%/*}"
		mount="$type"
		options="$mount_options"

		# Skip on unknown types.
		test "$type" = "label" && continue

		# Use the device name for empty labels.
		test -z "${label#$type/}" && label="$label$device"

		# Remember node.
		echo "$device;$label" >> "$nodes"

		# Create node hash for amd.
		hash="$(/sbin/md5 -qs "$device;$label")"

		echo "
# $label
$hash type:=program;fs:=\"$mountdir/$label\";\\
mount:=\"$0 mount mount $hash\";\\
unmount:=\"$0 umount umount $hash\"
" >> "$map"

		# Skip if already present.
		/usr/bin/grep -qFx "$device;$label" "$oldnodes" && continue

		# Create the media links.
		createLinks "$label" "$device"
	done

	# Clean up stale nodes, and keep mounted nodes.
	for line in $(/bin/cat "$oldnodes"); do
		/usr/bin/grep -qFx "$line" "$nodes" && continue

		device="${line%%;*}"
		label="${line##*;}"

		# Mounted nodes are not listed by every version of glabel,
		# so they have to protected.
		if /sbin/mount | grep -qF " $mountdir/$label "; then
			echo "$line" >> "$nodes"
			continue
		fi

		# Remove the stale media links.
		rmLinks "$label" "$device"
	done

	# Finally restart amd.
	until [ -n "$(/bin/cat "$pidfile" 2> "$devfs/null")" ]; do
		/bin/sleep 0.1
	done
	/bin/kill -HUP "$(/bin/cat "$pidfile" 2> "$devfs/null")"

	# Update geli managed mounts.
	geli_update

	# Clean up.
	/bin/rm "$oldnodes" 2> "$devfs/null"

	return 0
}

#
# Update geli encrypted providers. Requires the oldnodes file to be intact.
#
geli_update() {
	# Do not run if geli features are not activated.
	test "$geli" != "1" && return 0

	local keys key label name line update_amd device

	# Clean up keys from stale mounts.
	/usr/bin/touch "$oldnodes"
	keys="$(/bin/cat "$geli_availablekeys" 2> "$devfs/null")"
	for line in $(/bin/cat "$oldnodes"); do
		# Skip still present lines.
		/usr/bin/grep -qFx "$line" "$nodes" && continue
		label="${line##*;}"
		label="${label%;*}"

		# Forget keys belonging to this line.
		for key in $(echo "$keys" | /usr/bin/grep -E "^$label;"); do
			echo "del key: <${key##*;}> from <$label>"
		done
		keys="$(echo "$keys" | /usr/bin/grep -Ev "^$label;")"
	done

	# Now we check new mounts for keys.
	echo "$keys" | /usr/bin/grep -xv '' > "$geli_availablekeys"

	for line in $(/bin/cat "$nodes"); do
		/usr/bin/grep -qFx "$line" "$oldnodes" && continue
		label="${line#*;}"
		device="${line%%;*}"
	
		for key in $(
			/bin/ls "$linkdir/${devfs##*/}/$device/$geli_keys/" \
			2> "$devfs/null"
		); do
			echo "add key: <$key> from <$label>"
			echo "$label;$key" >> "$geli_availablekeys"
		done
	done

	# Look for stale images.
	/usr/bin/touch "$geli_nodes"
	/bin/mv "$geli_nodes" "$geli_oldnodes"
	for line in $(/bin/cat "$geli_oldnodes"); do
		name="${line%%;*}"
		device="${line#*;}"
		device="${device%;*}"
		label="${line##*;}"

		# This line must remain until the node has been destroyed.
		echo "$line" >> "$geli_nodes"

		# Skip if the key to this this image is still around.
		if /usr/bin/grep -qx "$label;$name" "$geli_availablekeys"; then
	 		continue
		fi

		# This image is stale. Fork a process that tries to unmount it.
		geli_unmount "$label" "$name" "$device" &
	done
	/usr/bin/touch "$geli_nodes"
	/bin/rm "$geli_oldnodes"

	# Attach encrypted devices. If necessary create them from images.
	update_amd=
	for key in $(/bin/cat "$geli_availablekeys"); do
		label="${key%;*}"
		name="${key##*;}"

		# The image with this name is already available as an md device.
		/usr/bin/grep -qE "^$name;" "$geli_nodes" && continue

		# There is no image with this name so there is nothing to do.
		test -e "$geli_images/$name" \
			-o -L "$geli_images/$name" || continue

		# Being here means that this image has not yet been made
		# available. So it is time to give it a try.
		key="$linkdir/$label/$geli_keys/$name"

		# Get the device to attach.
		if [ -L "$geli_images/$name" -a ! -e "$geli_images/$name" ]
		then
			# Get the device name from a link.
			device="$(/usr/bin/readlink "$geli_images/$name")"
		else
			# Create a file backed memory disk.
			device="$(/sbin/mdconfig -f "$geli_images/$name")"
			while [ ! -e "$devfs/$device" ]; do
				/bin/sleep 0.1
			done
		fi

		# Attempt to attach (decrypt) file.
		/usr/bin/cd "$(/usr/bin/dirname "$key")"
		if /sbin/geli attach -p -k "$key" "$device"; then
			# Remember success.
			echo "add encrypted provider: <$name> as <$device>" \
				"with key from <$label>"
			echo "$name;$device;$label" >> "$geli_nodes"
			update_amd=1
		else
			# Unsuccessful, clean up memory disk.
			/sbin/mdconfig -du "$device"
		fi
	done

	# Restart amd if a change has been made.
	if [ -n "$update_amd" ]; then
		update
	fi

	return 0
}

#
# Setup amd if not yet running and call update.
#
start() {
	local pid

	# There is no need to give geom time to update labels.
	update_delay=0

	if [ ! -e "$pidfile" ]; then
		/bin/cp "$static_map" "$map"
		"%%AMD%%" -r -p -a "$a" -c "$c" -w "$w" -l "$l" \
			"$directory" "$map" > "$pidfile" &
	fi

	$0 update &
}

#
# Kills the amd, unmounts all mounted partitions and cleans up everything.
#
stop() {
	local pid type label line device

	pid="$(/bin/cat "$pidfile" 2> "$devfs/null")"
	if [ -n "$pid" ]; then
		/bin/kill "$pid"
		wait "$pid" 2> "$devfs/null"
	fi
	
	# Clean up stale mounts.
	for line in $(/bin/cat "$nodes" 2> "$devfs/null"); do
		label="${line##*;}"
		device="${line%%;*}"

		rmLinks "$label" "$device"
	done

	# Clean up stale geli nodes.
	for line in $(/bin/cat "$geli_nodes" 2> "$devfs/null"); do
		device="${line#*;}"
		device="${device%;*}"

		/sbin/geli detach -f "$device"
		/sbin/mdconfig -du "$device"
	done

	# Clean up temporary folders.
	/bin/rmdir "$a" "$directory" "$mountdir" 2> "$devfs/null"
	/bin/rm "$pidfile" "$map" "$nodes" \
		 "$geli_availablekeys" "$geli_nodes" \
		 2> "$devfs/null"

	return 0
}

#
# List mounted, labels, keys, images or one of these categories.
#
list() {
	# This is not a reliable way to ensure that everything will go right,
	# but the probabality that bogus output will appear is rather low
	# and not aquiring the lock allows everyone to use the list command.
	if [ -e "$lock" ]; then
		echo "Locked."
		return 1
	fi

	local image device hash label line

	# List mounted media.
	if [ -z "$1" -o "$1" = "mounted" ]; then
		for line in $(
			# Format: <device>;<label>
			/sbin/mount | grep "$mountdir" | \
				sed -E "s,$devfs/(.+) on $mountdir/(.*) \(.*,\1;\2,1"
		); {
			# If the given devices match a line just print
			# it and we are done. Otherwise look for the label
			# with a different device, which can happen with
			# fuse devices.
			device="${line%%;*}"
			if /usr/bin/grep -qFx "$line" "$nodes"; then
				echo "mounted: <${line#*;}> from <$device>"
			elif $(line="$(/usr/bin/grep -E ";${line#*;}$" "$nodes")"); then
				echo "mounted: <${line#*;}> from <${line%%;*}> as <$device>"
			fi
		}
	fi

	# Print the labels that are available for mounting.
	if [ -z "$1" -o "$1" = "labels" ]; then
		/usr/bin/sed -E 's/([^;]*);(.*)/label: <\2> from <\1>/1' \
			"$nodes" 2> "$devfs/null"
	fi

	# List the keys that have been found on mounted devices.
	if [ -z "$1" -o "$1" = "keys" ]; then
		/usr/bin/sed -E 's/(.*);(.*)/key: <\2> from <\1>/1' \
			"$geli_availablekeys" 2> "$devfs/null"
	fi

	# List the encrypted providers and their status.
	if [ -z "$1" -o "$1" = "encrypted" -o "$1" = "images" ]; then
		/usr/bin/sed -E 's/(.*);(.*);(.*)/encrypted provider: <\1> as <\2> with key from <\3>/1' \
			"$geli_nodes" 2> "$devfs/null"
		for image in $(/bin/ls "$geli_images/" 2> "$devfs/null"); do
			/usr/bin/grep -qx "$image;.*" "$geli_nodes" \
				2> "$devfs/null" && continue
			if [ -e "$geli_images/$image" ]; then
				echo "encrypted provider: <$image>"
			else
				device="$(/usr/bin/readlink \
					"$geli_images/$image")"
				echo "encrypted provider: <$image> as <$device>"
			fi
		done
	fi

	return 0
}

#
# This calls the apropriate mount command for a given hash.
#
# @param $1
#	The hash over the name of the device node to mount.
#
mount() {
	local label labels hash device

	# Go through the list of configured partitions.
	labels="$(/bin/cat "$nodes")"
	for label in $labels; do
		hash="$(/sbin/md5 -qs "$label")"

		# The current partition is the one we're supposed to mount.
		if [ "$hash" = "$1" ]; then
			device="${label%%;*}"
			label="${label#*;}"
			type="${label%%/*}"
			mount="$type"
			options="$mount_options"

			# Check for config file settings.
			if [ -n "$(eval "echo \"\$$type\"")" ]; then
				mount="$(eval "echo \"\$$type\"")"
			fi
			if [ -n "$(eval "echo \"\$${type}_options\"")" ]; then
				options="$(eval "echo \"\$${type}_options\"")"
			fi

			# Give over to the mount command.
			exec /sbin/mount -t "$mount" -o "$options" \
				"$devfs/$device" "$mountdir/$label"
		fi
	done
	echo "File system not found."
	return 1
}

#
# This just exists to work around bugs in fusefs. It simply calls the
# umount command of the OS unless evil_fuse is set to 1.
#
# @param $1
#	The hash over the name of the device node to unmount.
#
umount() {
	local label labels

	# Find the label for the current hash.
	label=
	labels="$(/bin/cat "$nodes")"
	for label in $labels; do
		if [ "$1" = "$(/sbin/md5 -qs "$label")" ]; then
			label="${label#*;}"
			break
		else
			label=
		fi
	done

	# Find out if we are a fuse file system and use dirty bug workaround.
	# This will lead to unexpected results with more than one fuse based
	# file system around. Fuse based file systems will only get unmounted
	# if files are not opened on any of them.
	if [ "$evil_fuse" = "1" ]; then
		local type
		type="$(
			/sbin/mount | /usr/bin/grep "$label" | \
				/usr/bin/sed -E "s,.* on $mountdir/$label \(([^,)]*).*,\1,1"
		)"

		# If there are any files opened on ANY fuse based file system
		# then we will NOT unmount.
		if [ "$type" = "fusefs" ]; then
			/usr/bin/fstat | \
				/usr/bin/grep -qE '\?\(fuse\)' && exit 1
		fi
	fi

	# Don't attempt umounts for active file systems.
	if /usr/bin/fstat | /usr/bin/grep -F " $mountdir/$label " > /dev/null; then
		exit 1
	fi

	# Give over to the system unmount command.
	exec /sbin/umount "$mountdir/$label" 2> /dev/null
}

# Ensure the lock is aquired. And run the requested command.
case "$1" in
	locked)
		case "$2" in
			start | update | stop)
				echo "automounter $2: $(/bin/date -u)"
				$2 "$3"
				return $?
			;;
			*)
				echo "automounter: unknown directive '$2'."
				echo "Usage: automounter" \
					"(start|update|list|stop)"
			;;
		esac
	;;
	list | mount | umount)
		$1 "$2"
	;;
	*)
		/usr/bin/lockf -st "$timeout" "$lock" $0 locked "$@" || \
			echo "Lock could not be aquired:" "$@"
	;;
esac


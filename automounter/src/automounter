#!/bin/sh -f
#
# Copyright (c) 2008
# Dominic Fandrey <kamikaze@bsdforen.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

version=1.3.4

# AMD parameters
a="%%RUN%%/automounter.amd"
c=2
w=1
l="%%RUN%%/automounter.amd.log"
directory="%%RUN%%/automounter.amd.mnt"
map="%%RUN%%/automounter.amd.map"

# The amd map that the dynamic mounts are appended to.
static_map="%%MAP%%"

# The location of the devfs.
devfs="%%DEVFS%%"

# A file to remember for which partitions automounter has been configured.
nodes="%%RUN%%/automounter.nodes"

# A temporary file for the partitions of the last run.
oldnodes="%%RUN%%/automounter.nodes.old"

# The pid of amd.
pidfile="%%RUN%%/automounter.amd.pid"

# This is where the links will be created to access the file systems.
linkdir="%%MEDIA%%"

# This is where the folders to mount the file systems into will be created.
mountdir="%%RUN%%/automounter.mnt"

# Lock file.
lock="%%RUN%%/automounter.lock"

# Geli is inactive, set this to anything but 0 to activate it.
geli=0

# A file to remember which geli encrypted images belong to which node.
#
# The file is in the following format:
# 	<imageName>;<mdDevice>;<keyLabel>
#
# It is expected to meet this extended regular expression: [^;]+;md[0-9]+;[^;]+
# 	imageName	is the filename of the image.
#	mdDevice	is the device node of the file backed memory disk as
#			it was returned by mdconfig.
#	keyLabel	is the absolute path to the key the image was activated
#			with.
# 	
geli_nodes="%%RUN%%/automounter.geli.nodes"

# A temporary file to recognize which nodes were available during the last run.
geli_oldnodes="%%RUN%%/automounter.geli.oldnodes"

# A file to remember where we can find which keys.
#
# The format is:
#	<label>;<keyName>
geli_availablekeys="%%RUN%%/automounter.geli.keys"

# GEOM ELI encrypted images location.
geli_images="%%GELI_IMAGES%%"

# GEOM ELI keys location.
geli_keys="%%GELI_KEYS%%"

# Timeout in seconds for aquiring the lock.
timeout=10

# The delay before the update command takes effect. This is necessary
# to ensure that geom knows about new labels.
update_delay=2

# The default mount options.
mount_options=rw,noatime,noexec

# Mount isos as cd9660.
iso9660=cd9660
iso9660_options=ro

# Dirty fusefs bug workaround.
evil_fuse=0

# Config file.
config="%%PREFIX%%/etc/automounter.conf"
if [ -e "$config" -a ! -d "$config" ]; then
	. "$config"
fi

IFS='
'

#
# Updates the amd.map, the list of partitions and the mount links, if amd
# is running.
#
update() {
	local device line partitions label type options hash \
		owner mode key keys

	# Give geom some time to identify the label.
	/bin/sleep "$update_delay"

	# Don't do anything if amd is not running.
	# This prevents automounter from starting too early from devd.
	/bin/sync
	if [ ! -e "$pidfile" ]; then
		echo "automounter not started"
		return 0
	fi

	# Start building a new map by copying the static one.
	/bin/cp "$static_map" "$map"

	/bin/mkdir -p "$a"
	/usr/bin/touch "$nodes"
	/bin/mv "$nodes" "$oldnodes"
	/usr/bin/touch "$nodes"

	# Change the blacklists' format into something that can be used in a
	# case statement.
	devices_blacklist="$(
		echo "${blacklist_devs}" | /usr/bin/sed -E \
			-e 's/,/|/g' -e 's,([[:space:]\\]),\\\1,g'
	)"
	nodes_blacklist="$(
		echo "${blacklist_nodes}" | /usr/bin/sed -E \
			-e 's/,/|/g' -e 's,([[:space:]\\]),\\\1,g'
	)"

	# Create a list in the shape:
	#
	# device
	# label
	# --
	# device
	# label
	# --
	# ...
	partitions="$(
		/sbin/glabel list | /usr/bin/grep -A2 'Geom name: ' | \
		/usr/bin/grep -v 'Providers:' | \
		/usr/bin/sed -E -e 's/Geom name: (.*)/\1/1' \
			-e 's/.*Name: (.*)/\1/1'
	)"

	# Add new mounts.
	device=
	for line in $partitions; {
		# A line separator is encountered, prepare everything
		# for dealing with the next line.
		if [ "$line" = "--" ]; then
			device=
			continue
		fi
		
		# The current line is the device name, remember it and
		# go on to the next line.
		if [ -z "$device" ]; then
			device="$line"
			continue
		fi

		# Finally we can set up a mount.
		label="$line"

		# Check weather the device is blacklisted.
		if [ -n "$devices_blacklist" ]; then
			eval "
				case '$device' in
					$devices_blacklist)
						device=
						continue
					;;
				esac
			"
		fi

		# Check weather the partition is blacklisted.
		if [ -n "$nodes_blacklist" ]; then
			eval "
				case '$label' in
					$nodes_blacklist)
						device=
						continue
					;;
				esac
			"
		fi

		type="${label%%/*}"
		mount="$type"
		options="$mount_options"

		# Skip on unknown types.
		test "$type" = "label" && continue

		# Remember node.
		echo "$label" >> "$nodes"

		# Create node hash for amd.
		hash="$(/sbin/md5 -qs "$label")"

		echo "
# $label
$hash type:=program;fs:=\"$mountdir/$label\";\\
mount:=\"$0 mount mount $hash\";\\
unmount:=\"$0 umount umount $hash\"
" >> "$map"

		# Skip if already present.
		/usr/bin/grep -qx "$label" "$oldnodes" && continue

		# Create mount hooks.
		echo "add label: <$label> from <$device>"
		/bin/mkdir -p "$mountdir/$label"

		# Inherit mount node owner from device.
		/usr/sbin/chown "$(
			/usr/bin/stat -f %u:%g "$devfs/$label"
		)" "$mountdir/$label"

		# Inherit permissions from device. Add the executable
		# bit if read or write are permitted.
		/bin/chmod "$(
			/usr/bin/stat -f %p "$devfs/$label" | \
				/usr/bin/sed -e 's/.//1' \
					-e 's/2/3/g' \
					-e 's/4/5/g' \
					-e 's/6/7/g'
		)" "$mountdir/$label"

		# Create the link that invokes amd.
		/bin/mkdir -p "$linkdir/$type"
		/bin/ln -s "$directory/$hash" \
			"$linkdir/$label"
	}

	# Clean up stale mounts.
	for label in $(/bin/cat "$oldnodes"); {
		/usr/bin/grep -qx "$label" "$nodes" && continue

		type="${label%%/*}"
		hash="$(/sbin/md5 -qs "$label")"

		echo "del label: <$label>"
		/bin/rm "$linkdir/$label"
		/bin/rmdir "$linkdir/$type" 2> "$devfs/null"
		/bin/rmdir "$mountdir/$label"
		/bin/rmdir "$mountdir/$type" 2> "$devfs/null"

		# Forget keys belonging to this label.
		keys="$(echo "$keys" | grep -Ev "^$label;")"
	}

	# Finally restart amd.
	until [ -n "$(/bin/cat "$pidfile" 2> "$devfs/null")" ]; do
		/bin/sleep 0.1
	done
	/bin/kill -HUP "$(/bin/cat "$pidfile" 2> "$devfs/null")"

	# Update geli managed mounts.
	geli_update

	# Clean up.
	/bin/rm "$oldnodes" 2> "$devfs/null"

	return 0
}

#
# Update geli encrypted images. Requires the oldnodes file to be intact.
#
geli_update() {
	# Do not run if geli features are not activated.
	test "$geli" != "1" && return 0

	local keys key label name line update_amd

	# Clean up keys from stale mounts.
	/usr/bin/touch "$oldnodes"
	keys="$(/bin/cat "$geli_availablekeys" 2> "$devfs/null")"
	for label in $(/bin/cat "$oldnodes"); {
		/usr/bin/grep -qx "$label" "$nodes" && continue

		# Forget keys belonging to this label.
		for line in $(echo "$keys" | /usr/bin/grep -E "^$label;"); {
			echo "del key: <${line#*;}> from <${line%%;*}>"
		}
		keys="$(echo "$keys" | /usr/bin/grep -Ev "^$label;")"
	}

	# Now we check new mounts for keys.
	/bin/rm "$geli_availablekeys" 2> "$devfs/null"
	echo "$keys" | /usr/bin/grep -xv '' > "$geli_availablekeys"

	for label in $(/bin/cat "$nodes"); {
		/usr/bin/grep -qx "$label" "$oldnodes" && continue
	
		for key in $(
			/bin/ls "$linkdir/$label/$geli_keys/" \
			2> "$devfs/null"
		); {
			echo "add key: <$key> from <$label>"
			echo "$label;$key" >> "$geli_availablekeys"
		}
	}

	# Look for stale images.
	/usr/bin/touch "$geli_nodes"
	/bin/mv "$geli_nodes" "$geli_oldnodes"
	for line in $(/bin/cat "$geli_oldnodes"); {
		name="${line%%;*}"
		device="${line#*;}"
		device="${device%;*}"
		label="${line##*;}"

		# This line must remain until the node has been destroyed.
		echo "$line" >> "$geli_nodes"

		# Skip if the key to this this image is still around.
		if /usr/bin/grep -qx "$label;$name" "$geli_availablekeys"; then
	 		continue
		fi

		# This image is stale. Fork a process that tries to unmount it.
		(
			# Attempt to detach until successful or until the
			# key has returned.
			while true; do
				/bin/sleep 1
				# Skip if the key to this image has returned.
				/usr/bin/lockf "$lock" /bin/sh -c "
					if /usr/bin/grep -qx '$label;$name' \
						'$geli_availablekeys'; then
						exit 0
					else
						/sbin/geli detach '$device' \
							2> '$devfs/null' \
							|| exit 1
						/bin/mv '$geli_nodes' \
							'$geli_oldnodes'
						/usr/bin/grep -vx '$line' \
							'$geli_oldnodes' \
							> '$geli_nodes'
						/bin/rm '$geli_oldnodes'
						exit 2
					fi
				"
				case $? in
					0)
						# The key is back, no more
						# need to detach.
						exit 0
					;;
					1)
						# Detach failed.
						continue
					;;
					2)
						# Detach succeeded.
						echo "del encrypted image:" \
							"<$name> as <$device>" \
							"with key from <$label>"
						break
					;;
				esac
			done
			# Update labels in a locked fashion.
			$0 update &

			# Hang around to remove the device node for the image.
			# Unless it's a device link.
			if [ -e "$geli_images/$name" ]; then
				until /sbin/mdconfig -du "$device"; do
					/bin/sleep 1
				done
			fi
		) &

	}
	/usr/bin/touch "$geli_nodes"
	/bin/rm "$geli_oldnodes"

	# Attach encrypted devices. If necessary create them from images.
	update_amd=
	for key in $(/bin/cat "$geli_availablekeys"); {
		label="${key%;*}"
		name="${key##*;}"

		# The image with this name is already available as an md device.
		/usr/bin/grep -qE "^$name;" "$geli_nodes" && continue

		# There is no image with this name so there is nothing to do.
		test -e "$geli_images/$name" \
			-o -L "$geli_images/$name" || continue

		# Being here means that this image has not yet been made
		# available. So it is time to give it a try.
		key="$linkdir/$label/$geli_keys/$name"

		# Get the device to attach.
		if [ -L "$geli_images/$name" -a ! -e "$geli_images/$name" ]
		then
			# Get the device name from a link.
			device="$(/usr/bin/readlink "$geli_images/$name")"
		else
			# Create a file backed memory disk.
			device="$(/sbin/mdconfig -f "$geli_images/$name")"
			while [ ! -e "$devfs/$device" ]; do
				/bin/sleep 0.1
			done
		fi

		# Attempt to attach (decrypt) file.
		/usr/bin/cd "$(/usr/bin/dirname "$key")"
		if /sbin/geli attach -p -k "$key" "$device"; then
			# Remember success.
			echo "add encrypted image: <$name> as <$device>" \
				"with key from <$label>"
			echo "$name;$device;$label" >> "$geli_nodes"
			update_amd=1
		else
			# Unsuccessful, clean up memory disk.
			/sbin/mdconfig -du "$device"
		fi
	}

	# Restart amd if a change has been made.
	if [ -n "$update_amd" ]; then
		update
	fi

	return 0
}

#
# Setup amd if not yet running and call update.
#
start() {
	local pid

	# There is no need to give geom time to update labels.
	update_delay=0

	if [ ! -e "$pidfile" ]; then
		/bin/cp "$static_map" "$map"
		"%%AMD%%" -r -p -a "$a" -c "$c" -w "$w" -l "$l" \
			"$directory" "$map" > "$pidfile" &
	fi

	$0 update &
}

#
# Kills the amd, unmounts all mounted partitions and cleans up everything.
#
stop() {
	local pid type label line device

	pid="$(/bin/cat "$pidfile" 2> "$devfs/null")"
	if [ -n "$pid" ]; then
		/bin/kill "$pid"
		wait "$pid" 2> "$devfs/null"
	fi
	
	# Clean up stale mounts.
	for label in $(/bin/cat "$nodes" 2> "$devfs/null"); {
		type="${label%%/*}"
		/sbin/umount -f "$mountdir/$label" > "$devfs/null" 2>&1

		echo "del: <$label>"
		/bin/rm "$linkdir/$label"
		/bin/rmdir "$linkdir/$type" 2> "$devfs/null"
		/bin/rmdir "$mountdir/$label"
		/bin/rmdir "$mountdir/$type" 2> "$devfs/null"
	}

	# Clean up stale geli nodes.
	for line in $(/bin/cat "$geli_nodes" 2> "$devfs/null"); {
		device="${line#*;}"
		device="${device%;*}"

		/sbin/geli detach -f "$device"
		/sbin/mdconfig -du "$device"
	}

	# Clean up temporary folders.
	/bin/rmdir "$a" "$directory" "$mountdir" 2> "$devfs/null"
	/bin/rm "$pidfile" "$map" "$nodes" \
		 "$geli_availablekeys" "$geli_nodes" \
		 2> "$devfs/null"

	return 0
}

#
# List mounted, labels, keys, images or one of these categories.
#
list() {
	# This is not a reliable way to ensure that everything will go right,
	# but the probabality that bogus output will appear is rather low
	# and not aquiring the lock allows everyone to use the list command.
	if [ -e "$lock" ]; then
		echo "Locked."
		return 1
	fi

	local image device hash label line

	# List mounted media.
	if [ -z "$1" -o "$1" = "mounted" ]; then
		for line in $(
			# Format: <device>;<hash>
			/sbin/mount | grep "$mountdir" | \
				sed -E "s,$devfs/(.+) on $mountdir/[^/]*/([a-f0-9]*).*,\1;\2,1"
		); {
			# If the given devices match a label just print
			# it and we are done. If not reconstruct the label
			# through the hash.
			if /usr/bin/grep -qx "${line%%;*}" "$nodes"; then
				echo "mounted: <${line%%;*}>"
			else
				for label in $(
					/bin/cat "$nodes" 2> "$devfs/null"
				); {
					hash="$(/sbin/md5 -qs "$label")"
					if [ "$hash" = "${line#*;}" ]; then
						echo "mounted: <$label>" \
							"as <${line%%;*}>"
					fi
				}
			fi
		}
	fi

	# Print the labels that are available for mounting.
	if [ -z "$1" -o "$1" = "labels" ]; then
		/usr/bin/sed -E 's/(.*)/label: <\1>/1' \
			"$nodes" 2> "$devfs/null"
	fi

	# List the keys that have been found on mounted devices.
	if [ -z "$1" -o "$1" = "keys" ]; then
		/usr/bin/sed -E 's/(.*);(.*)/key: <\2> from <\1>/1' \
			"$geli_availablekeys" 2> "$devfs/null"
	fi

	# List the images and their status.
	if [ -z "$1" -o "$1" = "images" ]; then
		/usr/bin/sed -E 's/(.*);(.*);(.*)/encrypted image: <\1> as <\2> with key from <\3>/1' \
			"$geli_nodes" 2> "$devfs/null"
		for image in $(/bin/ls "$geli_images/" 2> "$devfs/null"); {
			/usr/bin/grep -qx "$image;.*" "$geli_nodes" \
				2> "$devfs/null" && continue
			if [ -e "$geli_images/$image" ]; then
				echo "encrypted image: <$image>"
			else
				device="$(/usr/bin/readlink \
					"$geli_images/$image")"
				echo "encrypted image: <$image> as <$device>"
			fi
		}
	fi

	return 0
}

#
# This calls the apropriate mount command for a given hash.
#
# @param $1
#	The hash over the name of the device node to mount.
#
mount() {
	local label labels hash

	# Go through the list of configured partitions.
	labels="$(/bin/cat "$nodes")"
	for label in $labels; {
		hash="$(/sbin/md5 -qs "$label")"

		# The current partition is the one we're supposed to mount.
		if [ "$hash" = "$1" ]; then
			type="${label%%/*}"
			mount="$type"
			options="$mount_options"

			# Check for config file settings.
			if [ -n "$(eval "echo \"\$$type\"")" ]; then
				mount="$(eval "echo \"\$$type\"")"
			fi
			if [ -n "$(eval "echo \"\$${type}_options\"")" ]; then
				options="$(eval "echo \"\$${type}_options\"")"
			fi

			# Give over to the mount command.
			exec /sbin/mount -t "$mount" -o "$options" \
				"$devfs/$label" "$mountdir/$label"
		fi
	}
	echo "File system not found."
	return 1
}

#
# This just exists to work around bugs in fusefs. It simply calls the
# umount command of the OS unless evil_fuse is set to 1.
#
# @param $1
#	The hash over the name of the device node to unmount.
#
umount() {
	# Find the label for the current hash.
	label=
	labels="$(/bin/cat "$nodes")"
	for label in $labels; {
		if [ "$1" = "$(/sbin/md5 -qs "$label")" ]; then
			break
		else
			label=
		fi
	}

	# Find out if we are a fuse file system and use dirty bug workaround.
	# This will lead to unexpected results with more than one fuse based
	# file system around. Fuse based file systems will only get unmounted
	# if files are not opened on any of them.
	if [ "$evil_fuse" = "1" ]; then
		local type
		type="$(
			/sbin/mount | /usr/bin/grep "$label" | \
				/usr/bin/sed -E "s,.* on $mountdir/$label \(([^,)]*).*,\1,1"
		)"

		# If there are any files opened on ANY fuse based file system
		# then we will NOT unmount.
		if [ "$type" = "fusefs" ]; then
			/usr/bin/fstat | \
				/usr/bin/grep -qE '\?\(fuse\)' && exit 1
		fi
	fi

	# Don't attempt umounts for active file systems.
	if /usr/bin/fstat | /usr/bin/grep -F " $mountdir/$label " > /dev/null; then
		exit 1
	fi

	# Give over to the system unmount command.
	exec /sbin/umount "$mountdir/$label" 2> /dev/null
}

# Ensure the lock is aquired. And run the requested command.
case "$1" in
	locked)
		case "$2" in
			start | update | stop)
				echo "automounter $2: $(/bin/date -u)"
				$2 "$3"
				return $?
			;;
			*)
				echo "automounter: unknown directive '$2'."
				echo "Usage: automounter" \
					"(start|update|list|stop)"
			;;
		esac
	;;
	mount | umount | list)
		$1 "$2"
	;;
	*)
		/usr/bin/lockf -st "$timeout" "$lock" $0 locked "$@" || \
			echo "Lock could not be aquired:" "$@"
	;;
esac


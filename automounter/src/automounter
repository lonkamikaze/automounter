#!/bin/sh -f
#
# Copyright (c) 2008 - 2010
# Dominic Fandrey <kamikaze@bsdforen.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

version=1.4.2

# AMD parameters
a="%%RUN%%/automounter.amd"
c=10
w=5
l="%%RUN%%/automounter.amd.log"
directory="%%RUN%%/automounter.amd.mnt"
map="%%RUN%%/automounter.amd.map"

# The amd map that the dynamic mounts are appended to.
static_map="%%MAP%%"

# The location of the devfs.
devfs="%%DEVFS%%"

# A file to remember for which partitions automounter has been configured.
#
# Lines in the file conform to the following format:
#	<device>;<label>
#
# From the glabel detector perspective <device> is the geom consumer and
# <label> the provider.
#
# From the probe detector perspective <device> is the geom provider and
# <label> is a virtual convenience label.
nodes="%%VARTMP%%/automounter.nodes"

# A temporary file for the partitions of the last run.
oldnodes="%%TMP%%/automounter.nodes.old"

# A temporary mountpoint for probing.
probe="%%TMP%%/automounter.probe"

# Used to store a list of device that have already probed and shouldn't be
# reprobed. This is used to prevent the adding of devices that have been
# blacklisted through blacklist_nodes.
probed="%%TMP%%/automounter.probed"

# The pid of amd.
pidfile="%%RUN%%/automounter.amd.pid"

# This is where the links will be created to access the file systems.
linkdir="%%MEDIA%%"

# This is where the folders to mount the file systems into will be created.
mountdir="%%RUN%%/automounter.mnt"

# Lock file.
lock="%%RUN%%/automounter.lock"

# Geli is inactive, set this to anything but 0 to activate it.
geli=0

# A file to remember which geli encrypted providers belong to which node.
#
# The file is in the following format:
# 	<providerName>;<mdDevice>;<keyLabel>
#
# It is expected to meet this extended regular expression: [^;]+;md[0-9]+;[^;]+
# 	providerName	is the filename of the image or device link.
#	mdDevice	is the device node of the file backed memory disk as
#			it was returned by mdconfig.
#	keyLabel	is the absolute path to the key the image was activated
#			with.
# 	
geli_nodes="%%RUN%%/automounter.geli.nodes"

# A temporary file to recognize which nodes were available during the last run.
geli_oldnodes="%%RUN%%/automounter.geli.oldnodes"

# A file to remember where we can find which keys.
#
# The format is:
#	<label>;<keyName>
geli_availablekeys="%%RUN%%/automounter.geli.keys"

# GEOM ELI encrypted images and device link location.
geli_images="%%GELI_IMAGES%%"

# GEOM ELI keys location.
geli_keys="%%GELI_KEYS%%"

# Timeout in seconds for aquiring the lock.
timeout=10

# The delay before the update command takes effect. This is necessary
# to ensure that geom knows about new labels.
update_delay=2

# If set to 1 glabel file system detection is turned on.
detect_glabel=1

# If set to 1 iso9660 hard coding for devices is turned on.
detect_iso9660=1

# If set to 1 probe file system detection is turned on.
detect_probe=1

# The default mount options.
mount_options=rw,noatime,noexec

# Mount isos as cd9660.
iso9660=cd9660
iso9660_options=ro

# Dirty fusefs bug workaround.
evil_fuse=0

# A comma separated list of file system types to probe geom providers for.
probe_types=ufs,msdosfs,iso9660,ntfs,ext2fs

# A comma separated list of device patterns that are hardcoded to iso9660.
iso9660_devs="acd*,cd*"

# Config file.
config="%%PREFIX%%/etc/automounter.conf"
if [ -e "$config" -a ! -d "$config" ]; then
	. "$config"
fi

# devfs must not end with /
devfs="${devfs%/}"

IFS='
'

# Native error return codes.
readonly ERR_CMD_UNKNOWN=1
readonly ERR_NOT_STARTED=2
readonly ERR_MOUNT_FS_MISSING=3
readonly ERR_UMOUNT_ACTIVE=4
readonly ERR_LIST_LOCKED=5

# Locking error return codes.
readonly EX_USAGE=64
readonly EX_SOFTWARE=70
readonly EX_OSERR=71
readonly EX_CANTCREAT=73
readonly EX_TEMPFAIL=75

#
# Removes a set of media links.
#
# @param @
#	Expects a list of labels and devices in the form:
#		[<label> <device>]*
#
rmLinks() {
	local label device type

	while [ -n "$1" ]; do
		label="$1"
		device="$2"
		type="${label%%/*}"

		# Prepare for the next iteration.
		shift 2

		# Make sure this device is not mounted.
		/sbin/umount -f "$mountdir/$label" > "$devfs/null" 2>&1

		# Remove the stale label.
		echo "del label: <$label> from <$device>"
		/bin/rm "$linkdir/$label"
		/bin/rm "$linkdir/${devfs##*/}/$device.$type"
		/bin/rmdir "$linkdir/${devfs##*/}" 2> "$devfs/null"
		/bin/rmdir "$linkdir/$type" 2> "$devfs/null"
		/bin/rmdir "$mountdir/$label"
		/bin/rmdir "$mountdir/$type" 2> "$devfs/null"

		# Forget keys belonging to this label.
		keys="$(echo "$keys" | /usr/bin/grep -Fv ";$label;")"
	done
}

#
# Creates a set of media links.
#
# @param @
#	Expects a list of labels and devices in the form:
#		[<label> <device>]*
#
createLinks() {
	local label device type

	while [ -n "$1" ]; do
		label="$1"
		device="$2"
		type="${label%%/*}"

		# Prepare for the next iteration.
		shift 2
		
		# Create mount hooks.
		echo "add label: <$label> from <$device>"
		/bin/mkdir -p "$mountdir/$label"

		# Inherit mount node owner from device.
		/usr/sbin/chown "$(
			/usr/bin/stat -f %u:%g "$devfs/$label" 2> "$devfs/null" \
				|| /usr/bin/stat -f %u:%g "$devfs/$device"
		)" "$mountdir/$label"

		# Inherit permissions from device. Add the executable
		# bit if read or write are permitted.
		/bin/chmod "$(
			(
				/usr/bin/stat -f %p "$devfs/$label" \
				2> "$devfs/null" \
					|| /usr/bin/stat -f %p "$devfs/$device"
			) | /usr/bin/sed -e 's/.//1' \
				-e 's/2/3/g' \
				-e 's/4/5/g' \
				-e 's/6/7/g'
		)" "$mountdir/$label"

		# Create the links that invoke amd.
		/bin/mkdir -p "$linkdir/$type"
		/bin/mkdir -p "$linkdir/${devfs##*/}"
		/bin/ln -s "$directory/$hash" "$linkdir/$label"
		/bin/ln -s "$directory/$hash" "$linkdir/${devfs##*/}/$device.$type"
	done
}

#
# This function is forked by geliUpdate() to unmount images that do not longer
# have a key available.
#
# @param 1
#	The label of the key holding file system.
# @param 2
#	The name of the geli provider to unmount.
# @param 3
#	The device the geli provider is available as.
#
geliUnmount() {
	local label name device
	label="$1"
	name="$2"
	device="$3"

	# Attempt to detach until successful or until the
	# key has returned.
	while true; do
		/bin/sleep 1
		# Skip if the key to this image has returned.
		/usr/bin/lockf "$lock" /bin/sh -c "
			if /usr/bin/grep -qFx '$label;$name' \
				'$geli_availablekeys'; then
				exit 0
			else
				/sbin/geli detach '$device' \
					2> '$devfs/null' \
					|| exit 1
				/bin/mv '$geli_nodes' \
					'$geli_oldnodes'
				/usr/bin/grep -vFx '$line' \
					'$geli_oldnodes' \
					> '$geli_nodes'
				/bin/rm '$geli_oldnodes'
				exit 2
			fi
		"
		case $? in
			0)
				# The key is back, no more
				# need to detach.
				exit 0
			;;
			1)
				# Detach failed.
				continue
			;;
			2)
				# Detach succeeded.
				echo "del encrypted provider:" \
					"<$name> as <$device>" \
					"with key from <$label>"
				break
			;;
		esac
	done
	# Update labels in a locked fashion.
	$0 update delay &

	# Hang around to remove the device node for the image.
	# Unless it's a device link.
	if [ -e "$geli_images/$name" ]; then
		until /sbin/mdconfig -du "$device"; do
			/bin/sleep "$w"
		done
	fi
}

#
# This function checks whether the given device or label is blacklisted.
#
# @param 1
#	The device name of the discovered node.
# @param 2
#	The label of the discovered node.
# @param devices_blacklist
#	A list of glob patterns to check the device against.
# @param nodes_blacklist
#	A list glob patterns to check label nodes against.
# @return
#	0 if everything goes right
#	1 if the device is blacklisted
#	2 if the label is blacklisted
#
checkBlacklists() {
	local device label
	device="$1"
	label="$2"

	# Check weather the device is blacklisted.
	if [ -n "$devices_blacklist" ]; then
		eval "
			case '$device' in
				$devices_blacklist)
					return 1
				;;
			esac
		"
	fi

	# Check weather the partition is blacklisted.
	if [ -n "$nodes_blacklist" ]; then
		eval "
			case '$label' in
				$nodes_blacklist)
					return 2
				;;
			esac
		"
	fi
}

#
# This checks whether a revisit after cleanup is needed, because the device
# was previously discovered with a different label.
#
# @param 1
#	The name of the detector.
# @param 2
#	Set this if it is the revisit.
# @param device
#	The name of the device
# @param label
#	The label of the current device
# @param revisit
#	Add the detector if a second update run will be required to track a
#	label change.
# @return
#	0 (true)	if a revisit is required
#	1 (false)	otherwise
#
revisitNeeded() {
	test -n "$2" && return 1
	
	# If this was alredy discovered with a different label,
	# call for a revisit after the cleanup phase.
	if /usr/bin/grep -q "^$device;" "$oldnodes" \
		&& ! /usr/bin/grep -qFx "$device;$label" "$oldnodes"
	then
		# If not yet in the revisit list, add this detector.
		if [ "$revisit" = "${revisit%$1}" ]; then
			revisit="$revisit${revisit:+$IFS}$1"
		fi
		return 0
	fi

	return 1
}

# This function recors a node, creates the map file entry and calls
# createLinks. The idea is to separate this code from the device discovery
# code in the update() function.
#
# @param 1
#	The device name of the discovered node.
# @param 2
#	The label of the discovered node.
# @param devices_blacklist
#	A list of glob patterns to check the device against.
# @param nodes_blacklist
#	A list glob patterns to check label nodes against.
# @return
#	0 if everything goes right
#	1 if the device is blacklisted
#	2 if the label is blacklisted
#	3 if the file system type is not known, i.e. the label matches label/*
#
writeNode() {
	local device label type hash
	device="$1"
	label="$2"

	# Check weather device or label are blacklisted.
	checkBlacklists "$device" "$label" || return $?

	type="${label%%/*}"
	mount="$type"
	options="$mount_options"

	# Skip on unknown types.
	test "$type" = "label" && return 3

	# Use the device name for empty labels.
	test -z "${label#$type/}" && label="$label$device"

	# Remember node.
	echo "$device;$label" >> "$nodes"

	# Create node hash for amd.
	hash="$(/sbin/md5 -qs "$device;$label")"

	echo "
# $label
$hash type:=program;fs:=\"$mountdir/$label\";\\
mount:=\"$0 mount mount $hash\";\\
unmount:=\"$0 umount umount $hash\"
" >> "$map"

	# Skip if already present.
	if ! /usr/bin/grep -qFx "$device;$label" "$oldnodes"; then
		# Create the media links.
		createLinks "$label" "$device"
	fi
	return 0
}

#
# Make a trial mount in the probe directory. Make sure to run probeUnmount
# after succeeding.
#
# @param 1
#	The file system type to use for mounting.
# @param 2
#	The device to mount.
# @return
#	Whatever the mount command returns, 0 for success,
#	something else otherwise.
#
probeMount() {
	local type mount options device
	type="$1"
	device="$2"

	# Check for config file settings.
	if [ -n "$(eval "echo \"\$$type\"")" ]; then
		mount="$(eval "echo \"\$$type\"")"
	fi
	if [ -n "$(eval "echo \"\$${type}_options\"")" ]; then
		options="$(eval "echo \"\$${type}_options\"")"
	fi

	# Run the mount command.
	/sbin/mount -t "$mount" -o "$options" "$devfs/$device" "$probe" 2> "$devfs/null"
}

#
# Force unmount a probe mount.
#
probeUnmount() {
	/sbin/umount -f "$probe" 2> "$devfs/null"
}

#
# Detect already mounted devices and call writeNode().
#
# @param devices_blacklist
#	A list of glob patterns to check the device against.
# @param nodes_blacklist
#	A list glob patterns to check label nodes against.
#
mountedDetect() {
	local line device label

	# Keep mounted nodes.
	for line in $(/bin/cat "$oldnodes"); do
		/usr/bin/grep -qFx "$line" "$nodes" && continue

		device="${line%%;*}"
		label="${line##*;}"

		# Mounted nodes will not be detected by glabelDetect(),
		# because the label provider is removed as soon as the
		# consumer is mounted directly, which is what is done since
		# 1.3.6 to avoid problems with broken labels.
		if /sbin/mount | /usr/bin/grep -qF "on $mountdir/$label ("; then
			writeNode "$device" "$label"
			# Append to the list of already probed devices.
			echo "$device$IFS$label" >> "$probed"
		fi
	done
}

#
# Detect labeled devices and call writeNode().
#
# @param 1
#	If set this is considered a revisit.
# @param devices_blacklist
#	A list of glob patterns to check the devices against.
# @param nodes_blacklist
#	A list glob patterns to check label nodes against.
# @param revisit
#	Add glabel if a second update run will be required
#	to track a label change.
#
glabelDetect() {
	# Check whether glabel based file system discovery has been disabled.
	test "$detect_glabel" != "1" && return 0

	local partitions line device label

	# Create a list in the shape:
	#
	# device
	# label
	# --
	# device
	# label
	# --
	# ...
	partitions="$(
		/sbin/glabel list | /usr/bin/grep -A2 'Geom name: ' | \
		/usr/bin/grep -v 'Providers:' | \
		/usr/bin/sed -E -e 's/Geom name: (.*)/\1/1' \
			-e 's/.*Name: (.*)/\1/1'
	)"

	# Add new mounts.
	device=
	for line in $partitions; do
		# A line separator is encountered, prepare everything
		# for dealing with the next line.
		if [ "$line" = "--" ]; then
			device=
			continue
		fi
		
		# The current line is the device name, remember it and
		# go on to the next line.
		if [ -z "$device" ]; then
			device="$line"
			continue
		fi

		# Finally we can set up a mount.
		label="$line"

		# This is in the list of already probed devices. Do not check
		# the device node to be able to follow label changes.
		# Instead check for the device in the list of already
		# discovered nodes.
		if /usr/bin/grep -qFx "$label" "$probed" \
			|| /usr/bin/grep -q "^$device;" "$nodes"; then
			continue
		fi

		# Do not probe device IDs.
		case "$label" in
		*id/*)
			continue
		;;
		esac

		# Record the device to keep the following detectors from
		# probing.
		echo "$device" >> "$probed"

		# If this was alredy discovered with a different label, e.g.
		# because the label took too long to be discovered or was
		# changed, call for a revisit after the cleanup phase.
		if revisitNeeded glabel "$1"; then
			continue
		fi

		# Write the node.
		writeNode "$device" "$label"

		# Append to the list of already probed devices.
		echo "$label" >> "$probed"
	done
}

#
# Detect iso9660 devices without a disk or label and call writeNode().
#
# @param 1
#	If set this is considered a revisit.
# @param devices_blacklist
#	A list of glob patterns to check the devices against.
# @param nodes_blacklist
#	A list glob patterns to check label nodes against.
# @param revisit
#	Add iso9660 if a second update run will be required to track the
#	disappearance of a label.
#
iso9660Detect() {
	# Check whether iso9660 hard coding has been disabled.
	test "$detect_iso9660" != "1" && return 0

	local devices device label dev_pattern

	# Create a list of devices.
	devices="$(
		/usr/sbin/gstat -b -I0 | \
		/usr/bin/tail -n +3 | \
		/usr/bin/sed -E 's/([[:space:]]+[0-9.]+){9}[[:space:]]*//' | \
		/usr/bin/grep -v '/'
	)"

	# Change the iso9660_devs format into something that can be used in a
	# case statement.
	dev_pattern="$(
		echo "$iso9660_devs" | /usr/bin/sed -E \
			-e 's/^[[:space:]]*,//' -e 's/,[[:space:]]*$//' \
			-e 's/,/|/g' -e 's,([[:space:]\\]),\\\1,g'
	)"

	# Add new mounts.
	for device in $devices; do
		# This is in the list of already probed devices.
		if /usr/bin/grep -qFx "$device" "$probed"; then
			continue
		fi

		# Skip if the device is not in the pattern list.
		eval "
			case '$device' in
				$dev_pattern)
					# pass
				;;
				*)
					continue
				;;
			esac
		"

		label="iso9660/$device"

		# If this was previously discovered with a label, call for
		# a revisit after the cleanup phase.
		if revisitNeeded iso9660 "$1"; then
			continue
		fi

		# Write the node.
		writeNode "$device" "$label"

		# Append to the list of already probed devices.
		echo "$device$IFS$label" >> "$probed"
	done
}

#
# Detect labeled devices and call writeNode().
#
# @param 1
#	If set this is considered a revisit.
# @param devices_blacklist
#	A list of glob patterns to check the devices against.
# @param nodes_blacklist
#	A list glob patterns to check label nodes against.
# @param revisit
#	Add probe if a second update run will be required to track the
#	disappearance of a label or a file system type change.
#
probeDetect() {
	# Check whether probing based file system discovery has been disabled.
	test "$detect_probe" != "1" && return 0

	local devices device label type mount options

	# Reformat probe_types.
	probe_types="$(echo "$probe_types" | /usr/bin/egrep -o '[^,]+')"

	/bin/mkdir -p "$probe"

	# Create a list of devices.
	devices="$(
		/usr/sbin/gstat -b -I0 | \
		/usr/bin/tail -n +3 | \
		/usr/bin/sed -E 's/([[:space:]]+[0-9.]+){9}[[:space:]]*//' | \
		/usr/bin/grep -v '/'
	)"

	# Add new mounts.
	for device in $devices; do
		# This is in the list of already probed devices.
		if /usr/bin/grep -qFx "$device" "$probed"; then
			continue
		fi

		# Try probing every file system type.
		for type in $probe_types; do
			label="$type/$device"
			mount="$type"
			options="$mount_options"

			# Do not probe blacklisted devices.
			if ! checkBlacklists "$device" "$label"; then
				continue
			fi

			# Check for config file settings.
			if [ -n "$(eval "echo \"\$$type\"")" ]; then
				mount="$(eval "echo \"\$$type\"")"
			fi
			if [ -n "$(eval "echo \"\$${type}_options\"")" ]; then
				options="$(eval "echo \"\$${type}_options\"")"
			fi

			# Try to mount the device.
			if probeMount "$type" "$device"; then
				# Unmount the probe.
				probeUnmount

				# If this was previously discovered with a
				# label, or a different file system type, call
				# for a revisit after the cleanup phase.
				if revisitNeeded probe "$1"; then
					# Skip the following probes on this
					# device.
					break
				fi

				# Write the node.
				writeNode "$device" "$label"

				# Append to the list of already probed devices.
				echo "$device" >> "$probed"

				# Skip the following probes on this device.
				break
			fi

			# Add the label to the list of probed devices.
			echo "$label" >> "$probed"
		done
	done

	/bin/rmdir "$probe"
}

#
# Update the list of managed devices.
#
# Updates the amd.map, the list of partitions and the mount links, if amd
# is running.
#
# @param 1
#	If set delay the update.
# @return
#	ERR_NOT_STARTED, if automounter has not been started, otherwise 0.
#
update() {
	local device line partitions label type options
	local hash owner mode key detector revisit
	local devices_blacklist nodes_blacklist

	# Don't do anything if amd is not running.
	# This prevents automounter from starting too early from devd.
	/bin/sync
	test -e "$pidfile" || return $ERR_NOT_STARTED

	# Give geom some time to identify the label.
	test -n "$1" && /bin/sleep "$update_delay"

	# Start building a new map by copying the static one.
	/bin/cp "$static_map" "$map"

	/bin/mkdir -p "$a"
	/usr/bin/touch "$nodes"
	/bin/mv "$nodes" "$oldnodes"
	/usr/bin/touch "$nodes"
	echo > "$probed"

	# Change the blacklists' format into something that can be used in a
	# case statement.
	devices_blacklist="$(
		echo "${blacklist_devs}" | /usr/bin/sed -E \
			-e 's/^[[:space:]]*,//' -e 's/,[[:space:]]*$//' \
			-e 's/,/|/g' -e 's,([[:space:]\\]),\\\1,g'
	)"
	nodes_blacklist="$(
		echo "${blacklist_nodes}" | /usr/bin/sed -E \
			-e 's/^[[:space:]]*,//' -e 's/,[[:space:]]*$//' \
			-e 's/,/|/g' -e 's,([[:space:]\\]),\\\1,g'
	)"

	# Run detectors.
	revisit=
	for detector in mounted glabel iso9660 probe mounted; do
		/bin/sync
		${detector}Detect
	done

	# Remove no longer listed nodes.
	for line in $(/usr/bin/grep -vFx "$(/bin/cat "$nodes")" "$oldnodes"); do
		device="${line%%;*}"
		label="${line##*;}"

		# Remove the stale media links.
		rmLinks "$label" "$device"
	done

	# Revisit detectors requesting it.
	for detector in $revisit; do
		/bin/sync
		${detector}Detect revisit
	done

	# Finally reload amd map.
	until [ -n "$(/bin/cat "$pidfile" 2> "$devfs/null")" ]; do
		/bin/sleep 0.1
	done
	/bin/kill -HUP "$(/bin/cat "$pidfile" 2> "$devfs/null")"

	# Update geli managed mounts.
	geliUpdate

	# Clean up.
	/bin/rm "$oldnodes" "$probed" 2> "$devfs/null"

	return 0
}

#
# Update geli encrypted providers. Requires the oldnodes file to be intact.
#
geliUpdate() {
	# Do not run if geli features are not activated.
	test "$geli" != "1" && return 0

	local keys key label name line update_amd device

	# Clean up keys from stale mounts.
	/usr/bin/touch "$oldnodes"
	keys="$(/bin/cat "$geli_availablekeys" 2> "$devfs/null")"
	for line in $(/bin/cat "$oldnodes"); do
		# Skip still present lines.
		/usr/bin/grep -qFx "$line" "$nodes" && continue
		label="${line##*;}"
		label="${label%;*}"

		# Forget keys belonging to this line.
		for key in $(echo "$keys" | /usr/bin/grep -E "^$label;"); do
			echo "del key: <${key##*;}> from <$label>"
		done
		keys="$(echo "$keys" | /usr/bin/grep -Ev "^$label;")"
	done

	# Now we check new mounts for keys.
	echo "$keys" | /usr/bin/grep -xv '' > "$geli_availablekeys"

	for line in $(/bin/cat "$nodes"); do
		/usr/bin/grep -qFx "$line" "$oldnodes" && continue
		label="${line#*;}"
		device="${line%%;*}"

		for key in $(
			/bin/ls "$linkdir/${devfs##*/}/$device.${label%%/*}/$geli_keys/" 2> "$devfs/null"
		); do
			echo "add key: <$key> from <$label>"
			echo "$label;$key" >> "$geli_availablekeys"
		done
	done

	# Look for stale images.
	/usr/bin/touch "$geli_nodes"
	/bin/mv "$geli_nodes" "$geli_oldnodes"
	for line in $(/bin/cat "$geli_oldnodes"); do
		name="${line%%;*}"
		device="${line#*;}"
		device="${device%;*}"
		label="${line##*;}"

		# This line must remain until the node has been destroyed.
		echo "$line" >> "$geli_nodes"

		# Skip if the key to this this image is still around.
		if /usr/bin/grep -qx "$label;$name" "$geli_availablekeys"; then
	 		continue
		fi

		# This image is stale. Fork a process that tries to unmount it.
		geliUnmount "$label" "$name" "$device" &
	done
	/usr/bin/touch "$geli_nodes"
	/bin/rm "$geli_oldnodes"

	# Attach encrypted devices. If necessary create them from images.
	update_amd=
	for key in $(/bin/cat "$geli_availablekeys"); do
		label="${key%;*}"
		name="${key##*;}"

		# The image with this name is already available as an md device.
		/usr/bin/grep -qE "^$name;" "$geli_nodes" && continue

		# There is no image with this name so there is nothing to do.
		test -e "$geli_images/$name" \
			-o -L "$geli_images/$name" || continue

		# Being here means that this image has not yet been made
		# available. So it is time to give it a try.
		key="$linkdir/$label/$geli_keys/$name"

		# Get the device to attach.
		if [ -L "$geli_images/$name" -a ! -e "$geli_images/$name" ]
		then
			# Get the device name from a link.
			device="$(/usr/bin/readlink "$geli_images/$name")"
		else
			# Create a file backed memory disk.
			device="$(/sbin/mdconfig -f "$geli_images/$name")"
			while [ ! -e "$devfs/$device" ]; do
				/bin/sleep 0.1
			done
		fi

		# Attempt to attach (decrypt) file.
		if cd "$(/usr/bin/dirname "$key")" \
			&& /sbin/geli attach -p -k "$key" "$device"
		then
			# Remember success.
			echo "add encrypted provider: <$name> as <$device>" \
				"with key from <$label>"
			echo "$name;$device;$label" >> "$geli_nodes"
			update_amd=1
		else
			# Unsuccessful, clean up memory disk.
			/sbin/mdconfig -du "$device"
		fi
	done

	# Restart amd if a change has been made.
	if [ -n "$update_amd" ]; then
		update delay
	fi

	return 0
}

#
# Setup amd if not yet running and call update.
#
# @param 1
#	If set the update call is forked into the background.
#
start() {
	local pid

	if [ ! -e "$pidfile" ]; then
		/bin/cp "$static_map" "$map"
		"%%AMD%%" -r -p -a "$a" -c "$c" -w "$w" -l "$l" \
			"$directory" "$map" > "$pidfile" &
	fi

	if [ -n "$1" ]; then
		$0 update &
	else
		update
	fi
}

#
# Kills the amd, unmounts all mounted partitions and cleans up everything.
#
stop() {
	local pid type label line device

	pid="$(/bin/cat "$pidfile" 2> "$devfs/null")"
	if [ -n "$pid" ]; then
		/bin/kill "$pid"
		wait "$pid" 2> "$devfs/null"
	fi
	
	# Clean up stale mounts.
	for line in $(/bin/cat "$nodes" 2> "$devfs/null"); do
		label="${line##*;}"
		device="${line%%;*}"

		rmLinks "$label" "$device"
	done

	# Clean up stale geli nodes.
	for line in $(/bin/cat "$geli_nodes" 2> "$devfs/null"); do
		device="${line#*;}"
		device="${device%;*}"

		/sbin/geli detach -f "$device"
		/sbin/mdconfig -du "$device"
	done

	# Clean up temporary folders.
	/bin/rmdir "$a" "$directory" "$mountdir" 2> "$devfs/null"
	/bin/rm "$pidfile" "$map" "$nodes" \
		 "$geli_availablekeys" "$geli_nodes" \
		 2> "$devfs/null"

	return 0
}

#
# List mounted, labels, keys, encrypted providers or one of these categories.
#
# @param 1
#	Either "mounted", "labels", "keys" or "encrypted". If given only this
#	category will be listed.
# @return
#	ERR_LIST_LOCKED if the lock is currently held, 0 otherwise.
#
list() {
	# This is not a reliable way to ensure that everything will go right,
	# but the probabality that bogus output will appear is rather low
	# and not aquiring the lock allows everyone to use the list command.
	if [ -e "$lock" ]; then
		echo "Locked." 1>&2
		return $ERR_LIST_LOCKED
	fi

	local image device hash label line

	# List mounted media.
	if [ -z "$1" -o "$1" = "mounted" ]; then
		for line in $(
			# Format: <device>;<label>
			/sbin/mount | /usr/bin/grep "$mountdir" | \
				/usr/bin/sed -E "s,$devfs/(.+) on $mountdir/(.*) \(.*,\1;\2,1"
		); {
			# If the given devices match a line just print
			# it and we are done. Otherwise look for the label
			# with a different device, which can happen with
			# fuse devices.
			device="${line%%;*}"
			if /usr/bin/grep -qFx "$line" "$nodes"; then
				echo "mounted: <${line#*;}> from <$device>"
			elif $(line="$(/usr/bin/grep -E ";${line#*;}$" "$nodes")"); then
				echo "mounted: <${line#*;}> from <${line%%;*}> as <$device>"
			fi
		}
	fi

	# Print the labels that are available for mounting.
	if [ -z "$1" -o "$1" = "labels" ]; then
		/usr/bin/sed -E 's/([^;]*);(.*)/label: <\2> from <\1>/1' \
			"$nodes" 2> "$devfs/null"
	fi

	# List the keys that have been found on mounted devices.
	if [ -z "$1" -o "$1" = "keys" ]; then
		/usr/bin/sed -E 's/(.*);(.*)/key: <\2> from <\1>/1' \
			"$geli_availablekeys" 2> "$devfs/null"
	fi

	# List the encrypted providers and their status.
	if [ -z "$1" -o "$1" = "encrypted" -o "$1" = "images" ]; then
		/usr/bin/sed -E 's/(.*);(.*);(.*)/encrypted provider: <\1> as <\2> with key from <\3>/1' \
			"$geli_nodes" 2> "$devfs/null"
		for image in $(/bin/ls "$geli_images/" 2> "$devfs/null"); do
			/usr/bin/grep -qx "$image;.*" "$geli_nodes" \
				2> "$devfs/null" && continue
			if [ -e "$geli_images/$image" ]; then
				echo "encrypted provider: <$image>"
			else
				device="$(/usr/bin/readlink \
					"$geli_images/$image")"
				echo "encrypted provider: <$image> as <$device>"
			fi
		done
	fi

	return 0
}

#
# List data in machine readable form using absolute path names.
#
# @param 1
#	Either "mounted", "llinks" for labeled links or "dlinks" for device
#	links.
# @return
#	ERR_LIST_LOCKED if the lock is currently held, 0 otherwise.
#
mlist() {
	# This is not a reliable way to ensure that everything will go right,
	# but the probabality that bogus output will appear is rather low
	# and not aquiring the lock allows everyone to use the list command.
	if [ -e "$lock" ]; then
		return $ERR_LIST_LOCKED
	fi

	# Print mounted file systems.
	if [ -z "$1" -o "$1" = "mounted" ]; then
		for line in $(
			# Format: <device>;<label>
			/sbin/mount | /usr/bin/grep "$mountdir" | \
				/usr/bin/sed -E "s,$devfs/(.+) on $mountdir/(.*) \(.*,\1;\2,1"
		); {
			# If the given devices match a line just print
			# it and we are done. Otherwise look for the label
			# with a different device, which can happen with
			# fuse devices.
			if /usr/bin/grep -qFx "$line" "$nodes"; then
				echo "$mountdir/${line#*;}"
			elif $(line="$(/usr/bin/grep -E ";${line#*;}$" "$nodes")"); then
				device="${line%%;*}"
				echo "$mountdir/${line#*;}"
			fi
		}
	fi

	# Print the labels that are available for mounting.
	if [ -z "$1" -o "$1" = "llinks" ]; then
		/usr/bin/sed "s,[^;]*;,$linkdir/," "$nodes" 2> "$devfs/null"
	fi

	# Print the devices that are available for mounting.
	if [ -z "$1" -o "$1" = "dlinks" ]; then
		/usr/bin/sed -E "s,([^;]*);([^/]*).*,$linkdir/${devfs##*/}/\1.\2," "$nodes" 2> "$devfs/null"
	fi

	return 0
}

#
# This calls the apropriate mount command for a given hash.
#
# @param $1
#	The hash over the name of the device node to mount.
# @return
#	ERR_MOUNT_FS_MISSING if the file system to mount cannot be identified,
#	otherwise "exec /sbin/mount" is called.
#
mount() {
	local label labels hash device

	# Go through the list of configured partitions.
	labels="$(/bin/cat "$nodes")"
	for label in $labels; do
		hash="$(/sbin/md5 -qs "$label")"

		# The current partition is the one we're supposed to mount.
		if [ "$hash" = "$1" ]; then
			device="${label%%;*}"
			label="${label#*;}"
			type="${label%%/*}"
			mount="$type"
			options="$mount_options"

			# Check for config file settings.
			if [ -n "$(eval "echo \"\$$type\"")" ]; then
				mount="$(eval "echo \"\$$type\"")"
			fi
			if [ -n "$(eval "echo \"\$${type}_options\"")" ]; then
				options="$(eval "echo \"\$${type}_options\"")"
			fi

			# Give over to the mount command.
			exec /sbin/mount -t "$mount" -o "$options" \
				"$devfs/$device" "$mountdir/$label"
		fi
	done
	echo "File system not found."
	return $ERR_MOUNT_FS_MISSING
}

#
# This just exists to work around bugs in fusefs. It simply calls the
# umount command of the OS unless evil_fuse is set to 1.
#
# @param $1
#	The hash over the name of the device node to unmount.
# @return
#	ERR_UMOUNT_ACTIVE if the file system to be unmounted is active,
#	otherwise "exec /sbin/umount" is called.
#
umount() {
	local label device labels

	# Find the label for the current hash.
	label=
	device=
	labels="$(/bin/cat "$nodes")"
	for label in $labels; do
		if [ "$1" = "$(/sbin/md5 -qs "$label")" ]; then
			device="${label%%;*}"
			label="${label#*;}"
			break
		else
			label=
		fi
	done

	# Find out if we are a fuse file system and use dirty bug workaround.
	# This will lead to unexpected results with more than one fuse based
	# file system around. Fuse based file systems will only get unmounted
	# if files are not opened on any of them.
	if [ "$evil_fuse" = "1" ]; then
		local type
		type="$(
			/sbin/mount | /usr/bin/grep "$label" | \
				/usr/bin/sed -E "s,.* on $mountdir/$label \(([^,)]*).*,\1,1"
		)"

		# If there are any files opened on ANY fuse based file system
		# then we will NOT unmount.
		if [ "$type" = "fusefs" ]; then
			/usr/bin/fstat | \
				/usr/bin/grep -qE '\?\(fuse\)' && return $ERR_UMOUNT_ACTIVE
		fi
	fi

	# Don't attempt umounts for active file systems.
	if /usr/bin/fstat | /usr/bin/grep -F " $mountdir/$label " > "$devfs/null"; then
		return $ERR_UMOUNT_ACTIVE
	fi

	# If the device is missing (i.e. it was removed while being mounted),
	# force umount.
	if [ ! -e "$devfs/$device" ]; then
		echo "automounter: Force unmounting missing <$label> from <$device>" 1>&2
		# Schedule an update.
		$0 update 1 &
		exec /sbin/umount -f "$mountdir/$label" 2> "$devfs/null"
	fi

	# Give over to the system unmount command.
	exec /sbin/umount "$mountdir/$label" 2> "$devfs/null"
}

# Ensure the lock is aquired. And run the requested command.
case "$1" in
	locked)
		case "$2" in
			start | update | stop)
				$2 "$3"
				return
			;;
			umount)
				$2 "$3"
				return
			;;
		esac
	;;
	list | mlist | mount)
		$1 "$2"
		return
	;;
	umount)
		# Unmounts should not happen during updates.
		exec /usr/bin/lockf -st 0 "$lock" $0 locked "$@"
	;;
	start | update | stop)
		/usr/bin/lockf -st "$timeout" "$lock" $0 locked "$@"
		status=$?
		case $status in
			0 | $ERR_NOT_STARTED | $ERR_MOUNT_FS_MISSING | $ERR_UMOUNT_ACTIVE)
				# Silent success/fail
			;;
			$EX_USAGE | $EX_SOFTWARE | $EX_OSERR | $EX_CANTCREAT | $EX_TEMPFAIL)
				echo "automounter: Lock could not be aquired:" "$@" 1>&2
			;;
		esac
		return $status
	;;
	*)
		cat << HERE-DOC
automounter: unknown directive '$1'.
Usage:	automounter (start | update | list | mlist | stop)
	automounter list [mounted | labels | keys | encrypted]
	automounter mlist [mounted | llinks | dlinks]
HERE-DOC
		return $ERR_CMD_UNKNOWN
	;;
esac


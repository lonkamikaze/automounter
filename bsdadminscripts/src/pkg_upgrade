#!/bin/sh -f
#
# Copyright (c) 2009, 2010
# Dominic Fandrey <kamikaze@bsdforen.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

version=1.9
name=pkg_upgrade

# The path to run executables belonging to bsdadminscripts from.
rundir="${0%/${0##*/}}"
# The system prefix.
prefix="%%PREFIX%%"
# Default include path.
bsda_dir="%%DATADIR%%"
#HACK
prefix="/usr/local"
bsda_dir="${0%/${0##*/}}"
#hack
# The configuration file.
conf="$prefix/etc/$name.conf"

# Get some environment variables from uma. This includes PACKAGESITE,
# TMPDIR and PKG_INDEX and export them into the environment.
eval "$($rundir/uma env $$ | /usr/bin/sed -E "s/^([[:alnum:]_]+=')/export \1/1")"

# Load the confiugration file if present.
if [ -r "$conf" ]; then
	. "$conf"
fi

#
# Set sane environment defaults.
#
: ${PACKAGES="$(make -V PACKAGES -f /usr/share/mk/bsd.port.mk 2> /dev/null)"}
#HACK
: ${PACKAGES=/usr/ports/packages}
: ${PKG_DBDIR=/var/db/pkg}
: ${TMPDIR=/tmp}
#hack
: ${PACKAGES="%%PORTS%%/packages"}
: ${PKG_DBDIR=%%VAR%%/db/pkg}
: ${TMPDIR=%%TMP%%}
: ${PKG_TMPDIR=$TMPDIR}
: ${PKG_BACKUP_SUFX=.tbz}
: ${PKG_BACKUP_DIR="${PACKAGES%/}/pkg_upgrade-backup"}
: ${PKG_FILE_SUFX=.tbz}
: ${RUNDIR=$rundir}

# Export environment variables to ensure that every tool uses the same ones.
export PACKAGES PKG_DBDIR TMPDIR PKG_TMPDIR

# The following variables are only for use inside pkg_upgrade.
#	PKG_BACKUP_SUFX PKG_DOWNLOAD_SUFX RUNDIR

#
# Load libraries.
#

# Include object oriented framework.
. "${bsda_dir:-.}/bsda_obj.sh"

# Include terminal control library.
. "${bsda_dir:-.}/bsda_tty.sh"

# Import package handling classes.
. "${bsda_dir:-.}/bsda_pkg.sh"

# Import scheduling library.
. "${bsda_dir:-.}/bsda_scheduler.sh"

#
# Available flags.
#
readonly pu_FLAG_ALL=$((1 << 0))
readonly pu_FLAG_NO_BACKUP=$((1 << 1))
readonly pu_FLAG_CLEAN=$((1 << 2))
readonly pu_FLAG_REPLACE_CONFLICTS=$((1 << 3))
readonly pu_FLAG_LIST_DISCARDED=$((1 << 4))
readonly pu_FLAG_FORCE=$((1 << 5))
readonly pu_FLAG_FETCH_ONLY=$((1 << 6))
readonly pu_FLAG_HELP=$((1 << 7))
readonly pu_FLAG_NO_LOGGING=$((1 << 8))
readonly pu_FLAG_NO_ACTIONS=$((1 << 9))
readonly pu_FLAG_PARANOID=$((1 << 10))
readonly pu_FLAG_RECURSIVE=$((1 << 11))
readonly pu_FLAG_RECURSIVE2=$((1 << 12))
readonly pu_FLAG_UPWARD_RECURSIVE=$((1 << 13))
readonly pu_FLAG_UPWARD_RECURSIVE2=$((1 << 14))
readonly pu_FLAG_VERBOSE=$((1 << 15))
readonly pu_FLAG_EXIT_ON_CONFLICT=$((1 << 16))
readonly pu_FLAG_KEEP_INDEX=$((1 << 17))

#
# Available errors.
#
readonly pu_ERR_LOCK=1
readonly pu_ERR_str_1=ERR_LOCK
readonly pu_ERR_ARG=2
readonly pu_ERR_str_2=ERR_ARG
readonly pu_ERR_INDEX=3
readonly pu_ERR_str_3=ERR_INDEX
readonly pu_ERR_FETCH=4
readonly pu_ERR_str_4=ERR_FETCH
readonly pu_ERR_SORT=5
readonly pu_ERR_str_5=ERR_SORT
readonly pu_ERR_BACKUP_MISS=6
readonly pu_ERR_str_6=ERR_BACKUP_MISS
readonly pu_ERR_BACKUP_UNKNOWN=7
readonly pu_ERR_str_7=ERR_BACKUP_UNKNOWN
readonly pu_ERR_INSTALL=8
readonly pu_ERR_str_8=ERR_INSTALL
readonly pu_ERR_USER=9
readonly pu_ERR_str_9=ERR_USER
readonly pu_ERR_TERM=10
readonly pu_ERR_str_10=ERR_TERM
readonly pu_ERR_PACKAGE_FORMAT=11
readonly pu_ERR_str_11=ERR_PACKAGE_FORMAT
readonly pu_ERR_CONFLICT=12
readonly pu_ERR_str_12=ERR_CONFLICT
readonly pu_ERR_BACKUP_DIR=13
readonly pu_ERR_str_13=ERR_BACKUP_DIR
readonly pu_ERR_FILE_DIR=14
readonly pu_ERR_str_14=ERR_FILE_DIR

#
# Holds the current error state, one of pu_ERR_* or 0.
#
pu_errno=0

#
# A terminal object for this session.
#
bsda:tty:Terminal pu_terminal
# Trap this, just for starters until the Session object takes over.
trap "$pu_terminal.delete; exit $pu_ERR_USER" sighup sigint sigterm

#
# Parses the command line parameters.
#
# @param @
#	The parameters to parse.
# @param pu_errno
#	Error state keeping variable.
# @param pu_terminal
#	The current terminal.
# @return
#	Returns true (0) or false (1) in case of failure.
#
pu_params() {
	local IFS arg pkgPatterns pkgReplace flags errors resume

	IFS='
'

	# A list of explicit (re)install requests.
	pkgPatterns=
	# A list of replace requests, in the shape "<new>|<old>".
	pkgReplace=
	# A bit field for all the binary flags.
	flags=0
	# A list of error messages.
	errors=
	# Resume is a special case.
	resume=

	while [ $# -gt 0 ]; do
		arg="$1"
		shift
		case "$arg" in
		-a | --all)
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg All packages are already selected for processing."
			fi
			if [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Recursiveness has no effect, because all packages are already selected for processing."
			fi
			if [ $((flags & pu_FLAG_UPWARD_RECURSIVE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Upward recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_ALL))
		;;
		-b | --no-backup)
			if  [ $((flags & pu_FLAG_NO_BACKUP)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Backups can only be turned off once."
			fi
			flags=$((flags | pu_FLAG_NO_BACKUP))
		;;
		-c | --clean)
			if  [ $((flags & pu_FLAG_CLEAN)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Clean output was specified more than once."
			fi
			flags=$((flags | pu_FLAG_CLEAN))
		;;
		-C | --replace-conflicts)
			if  [ $((flags & pu_FLAG_REPLACE_CONFLICTS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Replace conflicts was specified more than once."
			fi
			if  [ $((flags & pu_FLAG_EXIT_ON_CONFLICT)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Replace conflicts and exit on conflict are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_REPLACE_CONFLICTS))
		;;
		-d | --list-discarded)
			if  [ $((flags & pu_FLAG_LIST_DISCARDED)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Listing discarded packages can only be requested once."
			fi
			flags=$((flags | pu_FLAG_LIST_DISCARDED))
		;;
		-f | --force)
			if  [ $((flags & pu_FLAG_FORCE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Forced reinstall can only be requested once."
			fi
			flags=$((flags | pu_FLAG_FORCE))
		;;
		-F | --fetch-only)
			if  [ $((flags & pu_FLAG_FETCH_ONLY)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Fetch only mode can only be requested once."
			fi
			if  [ $((flags & pu_FLAG_NO_ACTIONS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg The fetch only and no actions modes are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_FETCH_ONLY))
		;;
		-h | --help)
			if  [ $((flags & pu_FLAG_HELP)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Help can only be requested once."
			fi
			flags=$((flags | pu_FLAG_HELP))
		;;
		-k | --keep-index)
			if  [ $((flags & pu_FLAG_KEEP_INDEX)) -ne 0 ]; then
				if [ -n "$resume" ]; then
					errors="${errors:+$errors$IFS}$arg The keep index flag is already implied by the resume flag."
				else
					errors="${errors:+$errors$IFS}$arg The INDEX/MOVED/UPDATING files can only be kept once."
				fi
			fi
			flags=$((flags | pu_FLAG_KEEP_INDEX))
		;;
		-l | --no-logging)
			if  [ $((flags & pu_FLAG_NO_LOGGING)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Logging can only be turned off once."
			fi
			flags=$((flags | pu_FLAG_NO_LOGGING))
		;;
		-n | --no-actions)
			if  [ $((flags & pu_FLAG_NO_ACTIONS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg No actions mode can only be requested once."
			fi
			if  [ $((flags & pu_FLAG_FETCH_ONLY)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg The no actions and fetch only modes are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_NO_ACTIONS))
		;;
		-o | --origin)
			if [ -z "$1" ]; then
				errors="${errors:+$errors$IFS}$arg The origin flag expects a new package or origin as its first parameter."
			fi
			if [ -z "$2" ]; then
				errors="${errors:+$errors$IFS}$arg The origin flag expects an old package or origin as its second parameter."
			fi
			pkgReplace="${pkgReplace:+$pkgReplace$IFS}$1|$2"
			shift 2
		;;
		-p | --paranoid)
			if  [ $((flags & pu_FLAG_PARANOID)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Cannot be double paranoid."
			fi
			flags=$((flags | pu_FLAG_PARANOID))
		;;
		-r | --recursive)
			if  [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				if  [ $((flags & pu_FLAG_RECURSIVE2)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg Cannot be tripple recursive."
				fi
				flags=$((flags | pu_FLAG_RECURSIVE2))
			fi
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 -a $((flags & pu_FLAG_RECURSIVE)) -eq 0 ]; then
				errors="${errors:+$errors$IFS}$arg Recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_RECURSIVE))
		;;
		-R | --upward-recursive)
			if  [ $((flags & pu_FLAG_UPWARD_RECURSIVE)) -ne 0 ]; then
				if  [ $((flags & pu_FLAG_UPWARD_RECURSIVE2)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg Cannot be tripple upward recursive."
				fi
				flags=$((flags | pu_FLAG_UPWARD_RECURSIVE2))
			fi
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 -a $((flags & pu_FLAG_UPWARD_RECURSIVE)) -eq 0 ]; then
				errors="${errors:+$errors$IFS}$arg Upward recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_UPWARD_RECURSIVE))
		;;
		-s | --resume)
			if [ -z "$1" ]; then
				errors="${errors:+$errors$IFS}$arg The resume flag expects a session identifier to resume."
			fi
			if [ -n "$resume" ]; then
				errors="${errors:+$errors$IFS}$arg Only one session can be resumed at a time."
			else
				if  [ $((flags & pu_FLAG_KEEP_INDEX)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg The keep index flag is given, even though the resume flag implies it."
				fi
			fi
			flags=$((flags | pu_FLAG_KEEP_INDEX))
			resume="$1"
			shift
		;;
		-v | --verbose)
			if  [ $((flags & pu_FLAG_VERBOSE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Cannot be double verbose."
			fi
			flags=$((flags | pu_FLAG_VERBOSE))
		;;
		-X | --exit-on-conflict)
			if  [ $((flags & pu_FLAG_EXIT_ON_CONFLICT)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Exit on conflict was specified more than once."
			fi
			if  [ $((flags & pu_FLAG_REPLACE_CONFLICTS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Exit on conflict and replace conflicts are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_EXIT_ON_CONFLICT))
		;;
		--orgin=* | --resume=*)
			# Split long flags that expect parameters.
			set -- "${arg%%=*}" "${arg#*=}" "$@"
		;;
		-o* | -s*)
			# Split short flags that expect parameters.
			set -- "${arg%%${arg#-?}}" "${arg#-?}" "$@"
		;;
		-? | --*)
			# Complain about broken parameters.
			errors="${errors:+$errors$IFS}$arg Unknown parameter."
		;;
		-*)
			# Split concatenated parameters.
			set -- "${arg%%${arg#-?}}" "-${arg#-?}" "$@"
		;;
		'')
			# Ignore empty parameters.
		;;
		*)
			# Explicitely reinstall these.
			pkgPatterns="${pkgPatterns:+$pkgPatterns$IFS}$arg"
		;;
		esac
	done

	#
	# If errors occoured, print them and bail out.
	#
	if [ -n "$errors" ]; then
		echo "$errors" | /usr/bin/sed "s,^,ERROR(ERR_ARG=$pu_ERR_ARG): ," | $pu_terminal.stderr
		pu_errno=$pu_ERR_ARG
		return 1
	fi

	if pu:Session session $flags "$pkgPatterns" "$pkgReplace" $pu_terminal; then
		$session.getErrno pu_errno
		$session.delete
	fi
}



#
# An instance of this class represents a pkg_upgrade session.
#
# It holds all session information and can be terminated when an error occurs
#
bsda:obj:createClass pu:Session \
	implements:bsda:scheduler:Process \
	w:private:signal \
		"Is set to a signal if one was trapped." \
	w:private:flags \
		"The configuration flags." \
	w:private:terminal \
		"The Terminal object for this session." \
	w:private:index \
		"The Index object for this session." \
	w:private:downloader \
		"The download manager." \
	w:private:servers \
		"The download servers." \
	w:private:scheduler \
		"The scheduler to use." \
	w:private:state \
		"The current state of the Session." \
	w:private:packages \
		"A list of bsda:pkg:Package instances to process." \
	w:private:stateData \
		"Data storage for the currently running state." \
	w:private:stateStatus \
		"Status storage for the currently running state." \
	w:private:unindexed \
		"A list of installed origins that could not be returned" \
		"by the INDEX." \
	w:private:errno \
	x:public:getErrno \
		"The current error state of the session." \
	i:private:init \
		"The constructor initializes a session." \
	c:private:clean \
		"The destructor cleans up the session." \
	x:private:setupSignals \
		"Setup signal trapping." \
	x:private:setupTerminal \
		"Updates the terminal to use." \
	x:private:setupScheduler \
		"Setup the scheduler that takes over after preprocessing." \
	x:private:setupLock \
		"Creates an UMA lock." \
	x:private:setupIndex \
		"Updates the index." \
	x:private:setupDownloader \
		"Starts the download manager." \
	x:private:setupPkgs \
		"Setup the packages list." \
	x:private:setupImplicitPkgs \
		"Add implicit packages." \
	x:private:updateAll \
		"Adds all outdated packages." \
	x:private:updateDependencies \
		"Updates all dependencies." \
	x:private:getNewDependencies \
		"Returns a list of dependencies for a list of packages." \
	x:private:getNewDepending \
		"Returns a list of depending packages for a list of" \
		"packages." \
	x:private:sortPkgs \
		"Sortst the list of packages by dependency." \
	x:private:error \
		"Outputs an error message and sets errno." \
	x:private:warn \
		"Outputs a warning." \
	x:private:verbose \
		"Produce verbose output." \
	x:private:status \
		"Produce status output." \
	x:private:uma \
		"Calls UMA with the given parameters." \
	x:private:runVerify \
		"Run this in Verify state." \
	x:private:runStop \
		"Run this in Stop state." \

#
# @param 1
#	The flags for this session, a bitfield to read and write with the
#	pu_FLAG_* bits.
# @param 2
#	A list of explicite package matching patterns for install/reinstall.
# @param 3
#	The package replace instructions.
# @param 4
#	The terminal to use.
#
pu:Session.init() {
	local scheduler

	$this.setErrno 0
	$this.setFlags $1
	$this.setupTerminal $4
	$this.setupScheduler
	$this.setupLock || return 0
	$this.setupIndex || return 0
	$this.setupDownloader || return 0
	$this.setupPkgs "$3" "$2" || return 0
	$this.setupImplicitPkgs
	$this.sortPkgs
	#$this.setupSignals

#	$this.getScheduler scheduler
#	$this.verbose "Verifying package downloads."
#	$this.setState Verify
#	$scheduler.run

	local IFS packages pkg
	IFS='
'
	$this.getPackages packages
	for pkg in $packages; do
		$pkg.getOrigin
	done | $4.stdout
	$this.getPackages | wc -l | $4.stdout
	$this.getPackages | wc -l | sort -u | $4.stdout
}

pu:Session.clean() {
	local terminal
	$this.uma unlock
	$this.getTerminal terminal
	$terminal.delete
}

pu:Session.setupSignals() {
	trap "${this}signal=HUP" hup
	trap "${this}signal=INT" int
	trap "${this}signal=TERM" term
	trap - EXIT
}

pu:Session.setupTerminal() {
	local flags
	$this.getFlags flags
	$this.setTerminal $1

	# Turn off all the fancy terminal features if clean output was
	# requested.
	if [ $((flags & pu_FLAG_CLEAN)) -ne 0 ]; then
		$1.deactivate
	else
		$1.use 1
	fi
}

pu:Session.setupScheduler() {
	local scheduler sleeper
	# Create the scheduler.
	bsda:scheduler:RoundTripScheduler scheduler
	$this.setScheduler $scheduler

	# Create a sleeper job.
	bsda:scheduler:Sleep sleeper 1

	$scheduler.register $sleeper
	$scheduler.register $this
}

pu:Session.setupLock() {
	$this.verbose 'Acquiring an exclusive lock on the package database.'
	if ! $this.uma lock; then
		local gid
		gid="$(/usr/sbin/pw show user "$USER" | /usr/bin/cut -d: -f4)"
		if [ $gid -ne 0 ]; then
			$this.error $pu_ERR_LOCK "The command requires super user privileges."
		else
			$this.error $pu_ERR_LOCK "The uma (Update MAnager) lock could not be acquired, it appears the package/ports infrastructure is in use or there is make activity from the root user."
		fi
		return 1
	fi
}

pu:Session.setupIndex() {
	local flags index moved

	$this.verbose 'Opening the package INDEX for reading.'

	# Check whether a keep index is requested.
	$this.getFlags flags
	if [ $((flags & pu_FLAG_KEEP_INDEX)) -eq 0 ]; then
		# Try getting a new index.
		if ! $this.uma fetch ftpindex; then
			$this.error $pu_ERR_INDEX "Acquiring an up to date INDEX/MOVED/UPDATING failed."
			return 1
		fi
	fi
	if ! bsda:pkg:Moved moved "$PKG_MOVED"; then
		case $bsda_pkg_errno in
		$bsda_pkg_ERR_MOVED_FILE_MISSING)
			$this.error $pu_ERR_INDEX "Cannot read MOVED file at '$PKG_MOVED'."
		;;
		*)
			$this.error -1 "Unexpected error in line $LINENO."
		;;
		esac
		return 1
	fi
	if ! bsda:pkg:Index index "$PKG_INDEX" $moved "${PACKAGES%/}/All" "$PKG_FILE_SUFX" "$PKG_BACKUP_DIR" "$PKG_BACKUP_SUFX"; then
		case $bsda_pkg_errno in
		$bsda_pkg_ERR_INDEX_FILE_MISSING)
			$this.error $pu_ERR_INDEX "Cannot read INDEX file at '$PKG_INDEX'."
		;;
		$bsda_pkg_ERR_INDEX_MOVED_MISSING)
			$this.error $pu_ERR_INDEX "Cannot read MOVED file at '$PKG_MOVED'."
		;;
		$bsda_pkg_ERR_BACKUP_DIR_PERM)
			$this.error $pu_ERR_BACKUP_DIR "Cannot write to the package backup directory '$PKG_BACKUP_DIR'."
		;;
		*)
			$this.error -1 "Unexpected error in line $LINENO."
		;;
		esac
		return 1
	fi
	$this.setIndex $index
}

#
# Create a background downloader session.
#
pu:Session.setupDownloader() {
	local IFS flags master mirror servers downloader index
	IFS='
'

	# Check the flags.
	$this.getFlags flags
	if [ $((flags & pu_FLAG_NO_ACTIONS)) -ne 0 ]; then
		# This is just a simulation run, do not perform downloads.
		return 0
	fi

	# Check whether downloading is necessary.
	if [ "${PACKAGES%/}" = "${PACKAGESITE%/*?}" ]; then
		# Packages are available locally, through a networking FS
		# or nullfs_mount.
		return 0
	fi

	# Get the download locations.
	bsda:download:Server master "${PACKAGESITE%/*?}/All"
	mirrors=
	for mirror in $PACKAGESITE_MIRRORS; do
		bsda:download:Server mirror "${mirror%/*?}/All"
		mirrors="${mirrors:+$mirrors$IFS}$mirror"
	done

	# Create a collections of servers, bail out with errors.
	bsda:download:Servers servers $master $mirrors
	case $? in
	1)
		$this.error $pu_ERR_DOWNLOADER "The download manager could not be started, because of an unspecified problem with the master server defined in the PACKAGESITE environment variable."
		return 1
	;;
	2)
		$this.error $pu_ERR_DOWNLOADER "The download manager could not be started, because of an unspecified problem with at least one of the download mirrors defined in the PACKAGESITE_MIRRORS environment variable."
		return 1
	;;
	esac
	$this.setServers $servers

	# Start a background download manager that commits suicide if this
	# process dies.
	bsda:download:Manager downloader $servers $bsda_obj_pid
	$this.setDownloader $downloader

	# Tell the index about the download manager.
	$this.getIndex index
	if ! $index.registerDownloader $downloader; then
		case $bsda_pkg_errno in
		$bsda_pkg_ERR_DOWNLOADER_INVALID)
			$this.error -1 "Unexpected error in line $LINENO."
		;;
		$bsda_pkg_ERR_FILE_DIR_PERM)
			$this.error $pu_ERR_FILE_DIR "Downloading does not work, because there is no write access to '${PACKAGES%/}/All'."
		;;
		esac
		return 1
	fi
}

#
# @param 1
#	A list of package replace patterns in the form:
#		<new>|<old>
# @param 2
#	A list of package patterns to update/install/reinstall.
#
pu:Session.setupPkgs() {
	local IFS index packages substitution pattern pkg pkgs old new msg errno

	$this.verbose 'Parsing update, (re)install and replace instructions.'
	IFS='
'

	# The list of packages to work on.
	packages=
	$this.getIndex index
	# Get the substitution packages.
	for substitution in $1; do
		# Try to get the substitution package from the index.
		if $index.substitutePackage pkg "${substitution%%|*}" "${substitution#*|}"; then
			packages="${packages:+$packages$IFS}$pkg"
		else
			old="${substitution#*|}"
			new="${substitution%%|*}"
			msg="Replacing '$old' with '$new' failed"
			case $bsda_pkg_errno in
			$bsda_pkg_ERR_PACKAGE_CONTENTS_FORMAT)
				$this.error $pu_ERR_PACKAGE_FORMAT "$msg, because the CONTENTS format of '$new' is not understood."
			;;
			$bsda_pkg_ERR_PACKAGE_ORIGIN_UNMATCHED)
				$this.error $pu_ERR_ARG "$msg, because the origin glob '$new' does not match an installed package that is indexed."
			;;
			$bsda_pkg_ERR_PACKAGE_ORIGIN_UNINDEXED)
				$this.error $pu_ERR_ARG "$msg, because the origin '$new' is not indexed."
			;;
			$bsda_pkg_ERR_PACKAGE_NAME_UNMATCHED)
				$this.error $pu_ERR_ARG "$msg, because the package name glob '$new' does not match an installed package that is indexed."
			;;
			$bsda_pkg_ERR_PACKAGE_NAME_AMBIGUOUS)
				$this.error $pu_ERR_ARG "$msg, because the package name '$new' matches more than one indexed package."
			;;
			$bsda_pkg_ERR_PACKAGE_NAME_UNINDEXED)
				$this.error $pu_ERR_ARG "$msg, because the package name '$new' does not match an indexed package."
			;;
			$bsda_pkg_ERR_PACKAGE_NEW_ORIGIN_AMBIGUOUS)
				$this.error $pu_ERR_ARG "$msg, because the origin glob '$new' matches more than one installed and indexed package."
			;;
			$bsda_pkg_ERR_PACKAGE_NEW_NAME_AMBIGUOUS)
				$this.error $pu_ERR_ARG "$msg, because package name glob '$new' matches more than one installed and indexed package."
			;;
			$bsda_pkg_ERR_PACKAGE_OLD_ORIGIN_AMBIGUOUS)
				$this.error $pu_ERR_ARG "$msg, because the origin glob '$old' matches more than one installed package."
			;;
			$bsda_pkg_ERR_PACKAGE_OLD_ORIGIN_UNMATCHED)
				$this.error $pu_ERR_ARG "$msg, because the origin '$old' does not match an installed package."
			;;
			$bsda_pkg_ERR_PACKAGE_OLD_NAME_UNMATCHED)
				$this.error $pu_ERR_ARG "$msg, because the package name '$old' does not match an installed package."
			;;
			$bsda_pkg_ERR_PACKAGE_OLD_NAME_AMBIGUOUS)
				$this.error $pu_ERR_ARG "$msg, because the package name glob '$old' matches more than one installed package."
			;;
			$bsda_pkg_ERR_PACKAGE_OLD_CONFLICT)
				$this.error $pu_ERR_ARG "$msg, because replacing '$old' conflicts with other specified package operations."
			;;
			esac
			# Continue for the time being.
			bsda_pkg_errno=0
		fi
	done

	# Get the regular update/install/reinstall requests.
	for pattern in $2; do
		# Try to get the packages from the index.
		if $index.identifyPackages pkgs "$pattern"; then
			packages="${packages:+$packages$IFS}$pkgs"
		else
			msg="Updating or (re)installing '$pattern' failed"
			case $bsda_pkg_errno in
			$bsda_pkg_ERR_PACKAGE_CONTENTS_FORMAT)
				$this.error $pu_ERR_PACKAGE_FORMAT "$msg, because the CONTENTS format of '$pattern' is not understood."
			;;
			$bsda_pkg_ERR_PACKAGE_ORIGIN_UNMATCHED)
				$this.error $pu_ERR_ARG "$msg, because the origin glob '$pattern' does not match an installed package that is indexed."
			;;
			$bsda_pkg_ERR_PACKAGE_ORIGIN_UNINDEXED)
				$this.error $pu_ERR_ARG "$msg, because the origin '$pattern' is not indexed."
			;;
			$bsda_pkg_ERR_PACKAGE_NAME_UNMATCHED)
				$this.error $pu_ERR_ARG "$msg, because the package name glob '$pattern' does not match an installed package that is indexed."
			;;
			$bsda_pkg_ERR_PACKAGE_NAME_AMBIGUOUS)
				$this.error $pu_ERR_ARG "$msg, because the package name '$pattern' matches more than one indexed package."
			;;
			$bsda_pkg_ERR_PACKAGE_NAME_UNINDEXED)
				$this.error $pu_ERR_ARG "$msg, because the package name '$pattern' does not match an indexed package."
			;;
			esac
		fi
	done

	# Remove duplicates.
	packages="$(echo "$packages" | /usr/bin/sort -u)"
	# Store the packages to explicitely update or (re)install.
	$this.setPackages "$packages"

	# Start downloads.
	for pkg in $packages; do
		$pkg.fetch
	done

	# Return false if an error occured.
	$this.getErrno errno
	test $errno -eq 0
}

pu:Session.setupImplicitPkgs() {
	$this.updateAll
	$this.updateDependencies
}

pu:Session.updateAll() {
	local IFS local flags force origin operator index unindexed packages
	local origins pkg pkgs

	# Get the flags.
	$this.getFlags flags
	# Check whether the all flag is set.
	if [ $((flags & pu_FLAG_ALL)) -eq 0 ]; then
		# All flag is not set, skip this.
		return
	fi

	$this.verbose 'Checking all installed packages for updates.'

	IFS='
'

	# Get the force flag.
	force=
	if [ $((flags & pu_FLAG_FORCE)) -ne 0 ]; then
		force=1
	fi

	#
	# Get all outdated packages or simply all, in force mode.
	#

	# Get the index.
	$this.getIndex index
	# Get the list of unindexed packages.
	$this.getUnindexed unindexed
	# Collect the origins or packages matching the update criteria.
	origins=
	# Let pkg_version do the work of finding outdated packages.
	# Jump in where it fails.
	for origin in $(/usr/sbin/pkg_version -Io "$PKG_INDEX"); {
		operator="${origin##* }"
		origin="${origin%% *}"
		case "$operator" in
		'!' | '?' | '*')
			# pkg_version seems to output '!' where it should
			# output '?', so we treat them the same.
			# The examples for '*' in the pkg_version(1) manual
			# page are not up to date. The very idea of a '*'
			# ever occuring here gives me nightmares, but it's
			# probably still for the best to at least try and
			# handle this case with some grace.

			# The basic idea here is that bsda:pkg is more clever
			# than pkg_version. The missing origin might have
			# shown up in a package file or can be acquired from
			# the MOVED file.

			$index.getPackagesByOrigins pkg "$origin"

			# Check whether a package was returned.
			if [ -z "$pkg" ]; then
				# The package couldn't be identified,
				# this is the common case.
				unindexed="${unindexed:+$unindexed$IFS}$origin"
			else
				if [ -n "$force" ]; then
					# Always add in forced mode.
					origins="${origins:+$origins$IFS}$origin"
				elif $pkg.isUpdate; then
					# Otherwise only if this is an update.
					origins="${origins:+$origins$IFS}$origin"
				fi
			fi
		;;
		'=' | '>')
			# Up to date packages are not touched here unless
			# in force mode.
			test -n "$force" && origins="${origins:+$origins$IFS}$origin"
		;;
		'<')
			origins="${origins:+$origins$IFS}$origin"
		;;
		esac
	}

	# Update the unindexed origins.
	$this.setUnindexed "$(echo "$unindexed" | /usr/bin/sort -u)"

	#
	# Add all the origins.
	#

	# Note that everything in origins is guaranteed to be found, because
	# it's either in INDEX or has been found before. So there is no need
	# to check for missing packages.
	$this.getPackages packages
	$index.getPackagesByOrigins pkgs "$origins"
	# Remove duplicates.
	pkgs="$(echo "$pkgs" | grep -vxF "$packages")"
	$this.setPackages "$(echo "$packages${packages:+${pkgs:+$IFS}}$pkgs")"

	
	# Start downloads for new packages.
	for pkg in $pkgs; do
		$pkg.fetch
	done
}

pu:Session.updateDependencies() {
	local IFS flags dependencies depending packages pkg

	$this.verbose "Performing dependency checks."

	IFS='
'

	# Start with all packages currently enlisted.
	$this.getPackages packages

	# Single recursiveness is handled inside the getNewDep*() methods.
	$this.getNewDepending depending "$packages"
	$this.getNewDependencies dependencies "$packages"
	
	# Check deep recursion flags, if not set deactivate recursion flags
	# so that only obligatory checks are done recursively.
	$this.getFlags flags
	if [ $((flags & pu_FLAG_RECURSIVE2)) -eq 0 ]; then
		# Deep recursion is not activated, turn recursiveness off.
		flags=$((flags & (-1 ^ pu_FLAG_RECURSIVE)))
	fi
	if [ $((flags & pu_FLAG_UPWARD_RECURSIVE2)) -eq 0 ]; then
		# Deep recursion is not activated, turn recursiveness off.
		flags=$((flags & (-1 ^ pu_FLAG_UPWARD_RECURSIVE)))
	fi
	$this.setFlags $flags

	#
	# Now perform dependency checks until nothing new shows up.
	#
	while [ -n "$depending$dependencies" ]; do
		if [ -n "$dependencies" ]; then
			# Download new dependencies.
			for pkg in $dependencies; do
				$pkg.fetch
			done
			# Get upward dependencies for the new dependencies.
			$this.getNewDepending depending "$dependencies"
			packages="$packages${packages:+${dependencies:+$IFS}}$dependencies"
			$this.setPackages "$packages"
			dependencies=
		fi
		if [ -n "$depending" ]; then
			# Download new upward dependencies.
			for pkg in $depending; do
				$pkg.fetch
			done
			# Get dependencies for the new upward dependencies.
			$this.getNewDependencies dependencies "$depending"
			packages="$packages${packages:+${depending:+$IFS}}$depending"
			$this.setPackages "$packages"
			depending=
		fi
	done
}

#
# @param &1
#	The variable to store the new dependencies in.
# @param 2
#	The packages to check for missing dependencies.
#
pu:Session.getNewDependencies() {
	local IFS flags pkg pkgDepends depends packages time

	# Bail out without packages to check.
	if [ -z "$2" ]; then
		$caller.setvar "$1"
		return
	fi

	IFS='
'

	$this.status "Checking dependencies for $(($(echo "$2" | /usr/bin/wc -l))) packages ..."

	#
	# Get all dependencies of the requested packages.
	#
	# NOTE performance: can take a high number of seconds
	#
	packages="$2"
	depends=
	while [ -n "$packages" ]; do
		pkg="${packages%%$IFS*}"
		$pkg.getDependencies pkgDepends
		depends="$depends${depends:+${pkgDepends:+$IFS}}$pkgDepends"
		# Remove this package from the list of packages to ask for
		# dependencies. Because dependency information is recursive
		# also remove the just returned dependencies from the list.
		packages="$(echo "$packages" | /usr/bin/grep -vxF "$pkg${pkgDepends:+$IFS$pkgDepends}")"
	done

	# No dependencies, fine with me.
	if [ -z "$depends" ]; then
		$caller.setvar "$1"
		return
	fi

	# Get the already listed packages.
	$this.getPackages packages
	# Filter the dependencies by already known packages and remove
	# duplicates.
	depends="$(echo "$depends" \
		| /usr/bin/grep -vxF "$packages${packages:+${2:+$IFS}}$2" \
		| /usr/bin/sort -u
	)"

	#
	# Assemble a list of packages to return.
	#
	packages=
	# Check for recursive flag.
	$this.getFlags flags
	if [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
		if [ $((flags & pu_FLAG_FORCE)) -ne 0 ]; then
			# In force recursive mode all dependencies get added.
			packages="$depends"
		else
			# In plain recursive mode all dependencies missing
			# or outdated get added.
			for pkg in $depends; do
				if $pkg.isUpdate; then
					packages="${packages:+$packages$IFS}$pkg"
				fi
			done
		fi
	else
		# Only missing dependencies get added.
		for pkg in $depends; do
			if ! $pkg.isInstalled; then
				packages="${packages:+$packages$IFS}$pkg"
			fi
		done
	fi

	# Return the dependencies to add.
	$caller.setvar "$1" "$packages"
}

#
# @param &1
#	The variable to store the new dependencies in.
# @param 2
#	The packages to check for depending packages.
#
pu:Session.getNewDepending() {
	local IFS flags index packages all updates requests pkg depending
	local pkgDependencies

	# Bail out for empty parameters.
	if [ -z "$2" ]; then
		$caller.setvar "$1"
		return
	fi

	# Get the flags.
	$this.getFlags flags

	# If the force and all flag is set this will never yield something.
	if [ $((flags & pu_FLAG_ALL)) -ne 0 -a $((flags & pu_FLAG_FORCE)) -ne 0 ]; then
		$caller.setvar "$1"
		return
	fi

	IFS='
'

	$this.status "Checking upwards dependencies for $(($(echo "$2" | /usr/bin/wc -l))) packages ..."

	#
	# Compile a list of packages from the given ones, sort them into
	# updates and other request flags.
	#
	updates=
	requests=
	for pkg in $2; do
		if $pkg.isUpdate; then
			# This is an update request and thus processing
			# depending packages is obligatory.
			updates="${updates:+$updates$IFS}$pkg"
		else
			# The other ones are only needed when upward
			# recursiveness is set.
			if [ $((flags & pu_FLAG_UPWARD_RECURSIVE)) -ne 0 ]; then
				requests="${requests:+$requests$IFS}$pkg"
			fi
		fi
	done

	# Check whether any updates were found and whether the upward
	# recursive flag is not set.
	if [ -z "$updates" -a -z "$requests" ]; then
		# No updates and no upward recursiveness?
		# This time consuming endeavour can be skipped.
		$caller.setvar "$1"
		return
	fi

	#
	# Get a list of all packages.
	#
	# NOTE performance: can take several seconds
	# This takes very long (the first time)!
	# Using "pkg_info -R" would be faster, but
	# less reliable.
	#
	$this.getPackages packages
	$this.getIndex index
	# Get all installed packages, this is what takes so long.
	$index.identifyPackages all '*'
	# We don't need to check the ones already listed for processing.
	all="$(echo "$all" | /usr/bin/grep -vxF "${packages:+$packages$IFS}$2")"

	# Check all remaining packages, whether they depend on the given ones.
	depending=
	while [ -n "$all" ]; do
		pkg="${all%%$IFS*}"
		all="${all#$pkg}"
		all="${all#$IFS}"
		$pkg.getDependencies pkgDependencies
		if echo "$pkgDependencies" | /usr/bin/grep -qxF "${updates:-#}"; then
			# Packages depending on uppdates always get added.
			depending="${depending:+$depending$IFS}$pkg"
		elif echo "$pkgDependencies" | /usr/bin/grep -qxF "${requests:-#}"; then
			# Requests is only populated if upward recursiveness
			# is set.
			if [ $((flags & pu_FLAG_FORCE)) -ne 0 ]; then
				# In forced mode just add the package.
				depending="${depending:+$depending$IFS}$pkg"
			elif $pkg.isUpdate; then
				# This packe appears to be outdated, so add
				# it.
				depending="${depending:+$depending$IFS}$pkg"
			fi
		else
			# The current package does not need to be reinstalled,
			# thus all dependencies of it do not need to either.
			all="$(echo "$all" | /usr/bin/grep -vxF "$pkgDependencies")"
		fi
	done

	# Return the found depending packages.
	$caller.setvar "$1" "$depending"
}

pu:Session.sortPkgs() {
	local IFS packages pkg sorted dependencies dependency

	$this.verbose "Sorting packages by dependency."
	IFS='
'

	#
	# Sort the packages by dependency. The idea is to create a list of
	# packages by always inserting them in sorted order.
	#
	$this.getPackages packages
	$this.status "Sorting $(($(echo "$packages" | /usr/bin/wc -l))) packages ..."
	sorted=
	for pkg in $packages; do
		# Get the last dependency in the list of packages to sort.
		$pkg.getDependencies dependencies
		dependency="$(echo "$sorted" | /usr/bin/grep -Fx "$dependencies" | /usr/bin/tail -n1)"

		# Get the last matching dependency in the list.
		if [ -z "$dependency" ]; then
			sorted="$pkg${sorted:+$IFS$sorted}"
			continue
		fi

		sorted="$(echo "$sorted" | /usr/bin/sed -E "/^$dependency$/a\\$IFS$pkg$IFS")"
	done

	# Set the packages to the sorted list.
	$this.setPackages "$sorted"
}

#
# @param 1
#	The error number as defined in the pu_ERR_* constants.
# @param 2
#	The error message.
#
pu:Session.error() {
	eval "
	test \$${this}errno -eq 0 && ${this}errno=$1
	\$${this}terminal.stderr \"ERROR(\$pu_ERR_str_$1=$1): \$2\"
	"
}

pu:Session.warn() {
	eval "
	\$${this}terminal.stderr \"pkg_upgrade: \$1\"
	"
}

pu:Session.verbose() {
	eval "
	if [ \$((${this}flags & pu_FLAG_VERBOSE)) -ne 0 ]; then
		\$${this}terminal.stdout \"\$1\"
	fi
	\$${this}terminal.line 0 \"\${1%.} ...\"
	"
}

pu:Session.status() {
	eval "
	\$${this}terminal.line 0 \"\$1\"
	"
}

pu:Session.run() {
	local state

	#TODO signal handling

	# Run the current job.
	$this.getState state
	$this.run$state
}

pu:Session.runVerify() {
	local IFS index packages verified downloads pkg file errno
	local downloader null jobs job statusJob terminal speed unit
	local size progress line
	IFS='
'

	# Show download status if available.
	$this.getDownloader downloader
	if [ -n "$downloader" ]; then
		$downloader.run
		$downloader.getStatus null null null jobs
		$this.getStateStatus statusJob
		$this.getTerminal terminal
		statusJob="$(echo "$jobs" | /usr/bin/grep -Fx "$statusJob")"
		# Pick one job to be displayed.
		if [ -z "$statusJob" ]; then
			statusJob="${jobs%%$IFS*}"
		fi
		$this.setStateStatus $statusJob
		# Display a job, if one is active.
		if [ -n "$statusJob" ]; then
			$statusJob.getStatus file size full null null progress speed
			$terminal.convertBytes speed unit "$speed" 4
			speed="$speed ${unit}b/s"
			$terminal.convertBytes full unit "$full" 4
			full="$full ${unit}b"
			$terminal.convertBytesToUnit size "$unit" "$size" 4
			$terminal.format line '<-x-:s> <4:s> of <:s> (<3:d>%%) at <9:s>' "$file" "$size" "$full" "$progress" "$speed"
			$this.status "$line"
		else
			$this.status "Waiting for downloads ..."
		fi
	fi
	
	#
	# Verify completed downloads.
	#
	$this.getIndex index
	$this.getPackages packages
	$this.getStateData verified

	# Check for newly completed downloads.
	if $index.completedDownloads downloads; then
		# Verify each package that was returned.
		for pkg in $downloads; do
			if ! $pkg.verify file; then
				case $bsda_pkg_errno in
				$bsda_pkg_ERR_FILE_MISSING)
					$this.error $pu_ERR_FETCH "Downloading the file '$file' failed."
				;;
				$bsda_pkg_ERR_FILE_INVALID)
					$this.error $pu_ERR_FETCH "The file '$file' is not a valid package."
				;;
				*)
					$this.error -1 "Unexpected error in line $LINENO."
				;;
				esac
				bsda_pkg_errno=
			else
				$this.verbose "Downloading package file '${file##*/}' completed."
			fi
		done
		verified="${verified:+$verified$IFS}$downloads"
	fi

	$this.setStateData "$verified"

	# Check if this state is completed.
	if [ -z "$(echo "$packages" | /usr/bin/grep -vxF "$verified")" ]; then
		# If an error occured it's time to end this.
		$this.getErrno errno
		if [ $errno -ne 0 ]; then
			# Move to the next state.
			$this.setState Stop
		else
			# Move to the next state.
			$this.setState Stop
		fi
		# Clean up.
		$this.setStateData
		$this.setStateStatus
	fi
}

pu:Session.runStop() {
	local scheduler
	$this.getScheduler scheduler
	$scheduler.stop
}

pu:Session.stop() {
	return
}


#
# Calls UMA with the current PID.
#
# @param @
#	The parameters to pass on to uma.
#
pu:Session.uma() {
	$RUNDIR/uma $bsda_obj_pid "$@"
}

pu_params "$@"
return $pu_errno


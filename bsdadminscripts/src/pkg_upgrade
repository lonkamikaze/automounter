#!/bin/sh -f
#
# Copyright (c) 2009, 2010
# Dominic Fandrey <kamikaze@bsdforen.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

version=1.9
name=pkg_upgrade

# Constant path assignments.
rundir="${0%${0##*/}}"
#prefix="%%PREFIX%%"
prefix="/usr/local"
#var="%%VAR%%"
conf="$prefix/etc/$name.conf"

# Get some environment variables from uma. This includes PACKAGESITE,
# TMPDIR and PKG_INDEX and export them into the environment.
eval "$($rundir/uma env $$ | /usr/bin/sed -E "s/^([[:alnum:]_]+=')/export \1/1")"

# Load the confiugration file if present.
if [ -e "$conf" ]; then
	. "$conf"
fi

# Default include path.
#readonly bsda_dir="%%DATADIR%%"
bsda_dir="${0%${0##*/}}"

# Include terminal control library.
. "${bsda_dir:-.}/bsda_tty.sh"

# Import package handling classes.
. "${bsda_dir:-.}/bsda_pkg.sh"

# Import scheduling library.
. "${bsda_dir:-.}/bsda_scheduler.sh"

#
# Available flags.
#
readonly pu_FLAG_ALL=$((1 << 0))
readonly pu_FLAG_NO_BACKUP=$((1 << 1))
readonly pu_FLAG_CLEAN=$((1 << 2))
readonly pu_FLAG_REPLACE_CONFLICTS=$((1 << 3))
readonly pu_FLAG_LIST_DISCARDED=$((1 << 4))
readonly pu_FLAG_FORCE=$((1 << 5))
readonly pu_FLAG_FETCH_ONLY=$((1 << 6))
readonly pu_FLAG_HELP=$((1 << 7))
readonly pu_FLAG_NO_LOGGING=$((1 << 8))
readonly pu_FLAG_NO_ACTIONS=$((1 << 9))
readonly pu_FLAG_PARANOID=$((1 << 10))
readonly pu_FLAG_RECURSIVE=$((1 << 11))
readonly pu_FLAG_RECURSIVE2=$((1 << 12))
readonly pu_FLAG_UPWARD_RECURSIVE=$((1 << 13))
readonly pu_FLAG_UPWARD_RECURSIVE2=$((1 << 14))
readonly pu_FLAG_VERBOSE=$((1 << 15))
readonly pu_FLAG_EXIT_ON_CONFLICT=$((1 << 16))

#
# Available errors.
#
readonly pu_ERR_LOCK=1
readonly pu_ERR_str_1=ERR_LOCK
readonly pu_ERR_ARG=2
readonly pu_ERR_str_2=ERR_ARG
readonly pu_ERR_INDEX=3
readonly pu_ERR_str_3=ERR_INDEX
readonly pu_ERR_FETCH=4
readonly pu_ERR_str_4=ERR_FETCH
readonly pu_ERR_SORT=5
readonly pu_ERR_str_5=ERR_SORT
readonly pu_ERR_BACKUP_MISS=6
readonly pu_ERR_str_6=ERR_BACKUP_MISS
readonly pu_ERR_BACKUP_UNKNOWN=7
readonly pu_ERR_str_7=ERR_BACKUP_UNKNOWN
readonly pu_ERR_INSTALL=8
readonly pu_ERR_str_8=ERR_INSTALL
readonly pu_ERR_USER=9
readonly pu_ERR_str_9=ERR_USER
readonly pu_ERR_TERM=10
readonly pu_ERR_str_10=ERR_TERM
readonly pu_ERR_PACKAGE_FORMAT=11
readonly pu_ERR_str_11=ERR_PACKAGE_FORMAT
readonly pu_ERR_CONFLICT=12
readonly pu_ERR_str_12=ERR_CONFLICT

#
# A terminal object for this session.
#
bsda:tty:Terminal terminal
# Trap this, just for starters until the Session object takes over.
trap "$terminal.delete" EXIT

#
# Parses the command line parameters.
#
pu_params() {
	local IFS arg pkgPatterns pkgReplace flags errors

	IFS='
'

	# A list of explicit (re)install requests.
	pkgPatterns=
	# A list of replace requests, in the shape "<new>|<old>".
	pkgReplace=
	# A bit field for all the binary flags.
	flags=0
	# A list of error messages.
	errors=

	while [ $# -gt 0 ]; do
		arg="$1"
		shift
		case "$arg" in
		-a | --all)
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg All packages are already selected for processing."
			fi
			if [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Recursiveness has no effect, because all packages are already selected for processing."
			fi
			if [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Upward recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_ALL))
		;;
		-b | --no-backup)
			if  [ $((flags & pu_FLAG_NO_BACKUP)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Backups can only be turned off once."
			fi
			flags=$((flags | pu_FLAG_NO_BACKUP))
		;;
		-c | --clean)
			if  [ $((flags & pu_FLAG_CLEAN)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Clean output was specified more than once."
			fi
			flags=$((flags | pu_FLAG_CLEAN))
		;;
		-C | --replace-conflicts)
			if  [ $((flags & pu_FLAG_REPLACE_CONFLICTS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Replace conflicts was specified more than once."
			fi
			if  [ $((flags & pu_FLAG_EXIT_ON_CONFLICT)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Replace conflicts and exit on conflict are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_REPLACE_CONFLICTS))
		;;
		-d | --list-discarded)
			if  [ $((flags & pu_FLAG_LIST_DISCARDED)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Listing discarded packages can only be requested once."
			fi
			flags=$((flags | pu_FLAG_LIST_DISCARDED))
		;;
		-f | --force)
			if  [ $((flags & pu_FLAG_FORCE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Forced reinstall can only be requested once."
			fi
			flags=$((flags | pu_FLAG_FORCE))
		;;
		-F | --fetch-only)
			if  [ $((flags & pu_FLAG_FETCH_ONLY)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Fetch only mode can only be requested once."
			fi
			if  [ $((flags & pu_FLAG_NO_ACTIONS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg The fetch only and no actions modes are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_FETCH_ONLY))
		;;
		-h | --help)
			if  [ $((flags & pu_FLAG_HELP)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Help can only be requested once."
			fi
			flags=$((flags | pu_FLAG_HELP))
		;;
		-l | --no-logging)
			if  [ $((flags & pu_FLAG_NO_LOGGING)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Logging can only be turned off once."
			fi
			flags=$((flags | pu_FLAG_NO_LOGGING))
		;;
		-n | --no-actions)
			if  [ $((flags & pu_FLAG_NO_ACTIONS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg No actions mode can only be requested once."
			fi
			if  [ $((flags & pu_FLAG_FETCH_ONLY)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg The no actions and fetch only modes are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_NO_ACTIONS))
		;;
		-o | --origin)
			if [ -z "$1" ]; then
				errors="${errors:+$errors$IFS}$arg The origin flag expects a new package or origin as its first parameter."
			fi
			if [ -z "$2" ]; then
				errors="${errors:+$errors$IFS}$arg The origin flag expects an old package or origin as its second parameter."
			fi
			pkgReplace="${pkgReplace:+$pkgReplace$IFS}$1|$2"
			shift 2
		;;
		-o*)
			if [ -z "$1" ]; then
				errors="${errors:+$errors$IFS}$arg The origin flag expects an old package or origin as its second parameter."
			fi
			pkgReplace="${pkgReplace:+$pkgReplace$IFS}${arg#-o}|$1"
			shift
		;;
		-p | --paranoid)
			if  [ $((flags & pu_FLAG_PARANOID)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Cannot be double paranoid."
			fi
			flags=$((flags | pu_FLAG_PARANOID))
		;;
		-r | --recursive)
			if  [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				if  [ $((flags & pu_FLAG_RECURSIVE2)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg Cannot be tripple recursive."
				fi
				flags=$((flags | pu_FLAG_RECURSIVE2))
			fi
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 -a $((flags & pu_FLAG_RECURSIVE)) -eq 0 ]; then
				errors="${errors:+$errors$IFS}$arg Recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_RECURSIVE))
		;;
		-R | --upward-recursive)
			if  [ $((flags & pu_FLAG_UPWARD_RECURSIVE)) -ne 0 ]; then
				if  [ $((flags & pu_FLAG_UPWARD_RECURSIVE2)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg Cannot be tripple upward recursive."
				fi
				flags=$((flags | pu_FLAG_UPWARD_RECURSIVE2))
			fi
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 -a $((flags & pu_FLAG_UPWARD_RECURSIVE)) -eq 0 ]; then
				errors="${errors:+$errors$IFS}$arg Upward recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_UPWARD_RECURSIVE))
		;;
		-v | --verbose)
			if  [ $((flags & pu_FLAG_VERBOSE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Cannot be double verbose."
			fi
			flags=$((flags | pu_FLAG_VERBOSE))
		;;
		-X | --exit-on-conflict)
			if  [ $((flags & pu_FLAG_EXIT_ON_CONFLICT)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Exit on conflict was specified more than once."
			fi
			if  [ $((flags & pu_FLAG_REPLACE_CONFLICTS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Exit on conflict and replace conflicts are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_EXIT_ON_CONFLICT))
		;;
		-? | --*)
			# Complain about broken parameters.
			errors="${errors:+$errors$IFS}$arg Unknown parameter."
		;;
		-*)
			# Split concatenated parameters.
			set - "${arg%%${arg#-?}}" "-${arg#-?}" "$@"
		;;
		'')
			# Ignore empty parameters.
		;;
		*)
			# Explicitely reinstall these.
			pkgPatterns="${pkgPatterns:+$pkgPatterns$IFS}$arg"
		;;
		esac
	done

	#
	# Perform final parameter logic checks that cannot be performed on the
	# fly without enforcing a certain order of parameters.
	#
	if [ $((flags & pu_FLAG_RECURSIVE2)) -ne 0 -a $((flags & pu_FLAG_UPWARD_RECURSIVE)) -eq 0 ]; then
		errors="${errors:+$errors$IFS}Thorough recursiveness can only be used in conjunction with upwards recursiveness."
	fi

	#
	# If errors occoured, print them and bail out.
	#
	if [ -n "$errors" ]; then
		echo "$errors" | /usr/bin/sed "s,^,ERROR(ERR_ARG=$pu_ERR_ARG): ," | $terminal.stderr
		return $pu_ERR_ARG
	fi
}

#
# An instance of this class represents a pkg_upgrade session.
#
# It holds all session information and can be terminated when an error occurs
#
#
bsda:obj:createClass pu:Session \
	implements:bsda:scheduler:Process \
	w:private:terminal \
		"The Terminal object for this session." \
	w:private:index \
		"The Index object for this session." \
	w:private:moved \
		"The Moved object for a session." \
	i:private:init \
		"The constructor initializes a session." \

pu_params "$@"


#!/bin/sh -f
#
# Copyright (c) 2009, 2010
# Dominic Fandrey <kamikaze@bsdforen.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

version=1.9
name=pkg_upgrade

# The path to run executables belonging to bsdadminscripts from.
rundir="${0%/${0##*/}}"
# The system prefix.
prefix="%%PREFIX%%"
# Default include path.
bsda_dir="%%DATADIR%%"
#HACK
prefix="/usr/local"
bsda_dir="${0%/${0##*/}}"
#hack
# The configuration file.
conf="$prefix/etc/$name.conf"

# Get some environment variables from uma. This includes PACKAGESITE,
# TMPDIR and PKG_INDEX and export them into the environment.
eval "$($rundir/uma env $$ | /usr/bin/sed -E "s/^([[:alnum:]_]+=')/export \1/1")"

# Load the confiugration file if present.
if [ -e "$conf" ]; then
	. "$conf"
fi

#
# Set sane environment defaults.
#
: ${PKG_BACKUP_SUFX=.tbz}
: ${RUNDIR=$rundir}

# Make sure environment variables turn up in the environment.
export PKG_BACKUP_SUFX

#
# Load libraries.
#

# Include object oriented framework.
. "${bsda_dir:-.}/bsda_obj.sh"

# Include terminal control library.
. "${bsda_dir:-.}/bsda_tty.sh"

# Import package handling classes.
. "${bsda_dir:-.}/bsda_pkg.sh"

# Import scheduling library.
. "${bsda_dir:-.}/bsda_scheduler.sh"

#
# Available flags.
#
readonly pu_FLAG_ALL=$((1 << 0))
readonly pu_FLAG_NO_BACKUP=$((1 << 1))
readonly pu_FLAG_CLEAN=$((1 << 2))
readonly pu_FLAG_REPLACE_CONFLICTS=$((1 << 3))
readonly pu_FLAG_LIST_DISCARDED=$((1 << 4))
readonly pu_FLAG_FORCE=$((1 << 5))
readonly pu_FLAG_FETCH_ONLY=$((1 << 6))
readonly pu_FLAG_HELP=$((1 << 7))
readonly pu_FLAG_NO_LOGGING=$((1 << 8))
readonly pu_FLAG_NO_ACTIONS=$((1 << 9))
readonly pu_FLAG_PARANOID=$((1 << 10))
readonly pu_FLAG_RECURSIVE=$((1 << 11))
readonly pu_FLAG_RECURSIVE2=$((1 << 12))
readonly pu_FLAG_UPWARD_RECURSIVE=$((1 << 13))
readonly pu_FLAG_UPWARD_RECURSIVE2=$((1 << 14))
readonly pu_FLAG_VERBOSE=$((1 << 15))
readonly pu_FLAG_EXIT_ON_CONFLICT=$((1 << 16))
readonly pu_FLAG_KEEP_INDEX=$((1 << 17))

#
# Available errors.
#
readonly pu_ERR_LOCK=1
readonly pu_ERR_str_1=ERR_LOCK
readonly pu_ERR_ARG=2
readonly pu_ERR_str_2=ERR_ARG
readonly pu_ERR_INDEX=3
readonly pu_ERR_str_3=ERR_INDEX
readonly pu_ERR_FETCH=4
readonly pu_ERR_str_4=ERR_FETCH
readonly pu_ERR_SORT=5
readonly pu_ERR_str_5=ERR_SORT
readonly pu_ERR_BACKUP_MISS=6
readonly pu_ERR_str_6=ERR_BACKUP_MISS
readonly pu_ERR_BACKUP_UNKNOWN=7
readonly pu_ERR_str_7=ERR_BACKUP_UNKNOWN
readonly pu_ERR_INSTALL=8
readonly pu_ERR_str_8=ERR_INSTALL
readonly pu_ERR_USER=9
readonly pu_ERR_str_9=ERR_USER
readonly pu_ERR_TERM=10
readonly pu_ERR_str_10=ERR_TERM
readonly pu_ERR_PACKAGE_FORMAT=11
readonly pu_ERR_str_11=ERR_PACKAGE_FORMAT
readonly pu_ERR_CONFLICT=12
readonly pu_ERR_str_12=ERR_CONFLICT

#
# Holds the current error state, one of pu_ERR_* or 0.
#
pu_errno=0

#
# A terminal object for this session.
#
bsda:tty:Terminal pu_terminal
# Trap this, just for starters until the Session object takes over.
trap "$pu_terminal.delete" EXIT

#
# Parses the command line parameters.
#
# @param @
#	The parameters to parse.
# @param pu_errno
#	Error state keeping variable.
# @param pu_terminal
#	The current terminal.
# @return
#	Returns true (0) or false (1) in case of failure.
#
pu_params() {
	local IFS arg pkgPatterns pkgReplace flags errors resume

	IFS='
'

	# A list of explicit (re)install requests.
	pkgPatterns=
	# A list of replace requests, in the shape "<new>|<old>".
	pkgReplace=
	# A bit field for all the binary flags.
	flags=0
	# A list of error messages.
	errors=
	# Resume is a special case.
	resume=

	while [ $# -gt 0 ]; do
		arg="$1"
		shift
		case "$arg" in
		-a | --all)
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg All packages are already selected for processing."
			fi
			if [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Recursiveness has no effect, because all packages are already selected for processing."
			fi
			if [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Upward recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_ALL))
		;;
		-b | --no-backup)
			if  [ $((flags & pu_FLAG_NO_BACKUP)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Backups can only be turned off once."
			fi
			flags=$((flags | pu_FLAG_NO_BACKUP))
		;;
		-c | --clean)
			if  [ $((flags & pu_FLAG_CLEAN)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Clean output was specified more than once."
			fi
			flags=$((flags | pu_FLAG_CLEAN))
		;;
		-C | --replace-conflicts)
			if  [ $((flags & pu_FLAG_REPLACE_CONFLICTS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Replace conflicts was specified more than once."
			fi
			if  [ $((flags & pu_FLAG_EXIT_ON_CONFLICT)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Replace conflicts and exit on conflict are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_REPLACE_CONFLICTS))
		;;
		-d | --list-discarded)
			if  [ $((flags & pu_FLAG_LIST_DISCARDED)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Listing discarded packages can only be requested once."
			fi
			flags=$((flags | pu_FLAG_LIST_DISCARDED))
		;;
		-f | --force)
			if  [ $((flags & pu_FLAG_FORCE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Forced reinstall can only be requested once."
			fi
			flags=$((flags | pu_FLAG_FORCE))
		;;
		-F | --fetch-only)
			if  [ $((flags & pu_FLAG_FETCH_ONLY)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Fetch only mode can only be requested once."
			fi
			if  [ $((flags & pu_FLAG_NO_ACTIONS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg The fetch only and no actions modes are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_FETCH_ONLY))
		;;
		-h | --help)
			if  [ $((flags & pu_FLAG_HELP)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Help can only be requested once."
			fi
			flags=$((flags | pu_FLAG_HELP))
		;;
		-k | --keep-index)
			if  [ $((flags & pu_FLAG_KEEP_INDEX)) -ne 0 ]; then
				if [ -n "$resume" ]; then
					errors="${errors:+$errors$IFS}$arg The keep index flag is already implied by the resume flag."
				else
					errors="${errors:+$errors$IFS}$arg The INDEX/MOVED/UPDATING files can only be kept once."
				fi
			fi
			flags=$((flags | pu_FLAG_KEEP_INDEX))
		;;
		-l | --no-logging)
			if  [ $((flags & pu_FLAG_NO_LOGGING)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Logging can only be turned off once."
			fi
			flags=$((flags | pu_FLAG_NO_LOGGING))
		;;
		-n | --no-actions)
			if  [ $((flags & pu_FLAG_NO_ACTIONS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg No actions mode can only be requested once."
			fi
			if  [ $((flags & pu_FLAG_FETCH_ONLY)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg The no actions and fetch only modes are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_NO_ACTIONS))
		;;
		-o | --origin)
			if [ -z "$1" ]; then
				errors="${errors:+$errors$IFS}$arg The origin flag expects a new package or origin as its first parameter."
			fi
			if [ -z "$2" ]; then
				errors="${errors:+$errors$IFS}$arg The origin flag expects an old package or origin as its second parameter."
			fi
			pkgReplace="${pkgReplace:+$pkgReplace$IFS}$1|$2"
			shift 2
		;;
		-p | --paranoid)
			if  [ $((flags & pu_FLAG_PARANOID)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Cannot be double paranoid."
			fi
			flags=$((flags | pu_FLAG_PARANOID))
		;;
		-r | --recursive)
			if  [ $((flags & pu_FLAG_RECURSIVE)) -ne 0 ]; then
				if  [ $((flags & pu_FLAG_RECURSIVE2)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg Cannot be tripple recursive."
				fi
				flags=$((flags | pu_FLAG_RECURSIVE2))
			fi
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 -a $((flags & pu_FLAG_RECURSIVE)) -eq 0 ]; then
				errors="${errors:+$errors$IFS}$arg Recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_RECURSIVE))
		;;
		-R | --upward-recursive)
			if  [ $((flags & pu_FLAG_UPWARD_RECURSIVE)) -ne 0 ]; then
				if  [ $((flags & pu_FLAG_UPWARD_RECURSIVE2)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg Cannot be tripple upward recursive."
				fi
				flags=$((flags | pu_FLAG_UPWARD_RECURSIVE2))
			fi
			if  [ $((flags & pu_FLAG_ALL)) -ne 0 -a $((flags & pu_FLAG_UPWARD_RECURSIVE)) -eq 0 ]; then
				errors="${errors:+$errors$IFS}$arg Upward recursiveness has no effect, because all packages are already selected for processing."
			fi
			flags=$((flags | pu_FLAG_UPWARD_RECURSIVE))
		;;
		-s | --resume)
			if [ -z "$1" ]; then
				errors="${errors:+$errors$IFS}$arg The resume flag expects a session identifier to resume."
			fi
			if [ -n "$resume" ]; then
				errors="${errors:+$errors$IFS}$arg Only one session can be resumed at a time."
			else
				if  [ $((flags & pu_FLAG_KEEP_INDEX)) -ne 0 ]; then
					errors="${errors:+$errors$IFS}$arg The keep index flag is given, even though the resume flag implies it."
				fi
			fi
			flags=$((flags | pu_FLAG_KEEP_INDEX))
			resume="$1"
			shift
		;;
		-v | --verbose)
			if  [ $((flags & pu_FLAG_VERBOSE)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Cannot be double verbose."
			fi
			flags=$((flags | pu_FLAG_VERBOSE))
		;;
		-X | --exit-on-conflict)
			if  [ $((flags & pu_FLAG_EXIT_ON_CONFLICT)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Exit on conflict was specified more than once."
			fi
			if  [ $((flags & pu_FLAG_REPLACE_CONFLICTS)) -ne 0 ]; then
				errors="${errors:+$errors$IFS}$arg Exit on conflict and replace conflicts are mutually exclusive."
			fi
			flags=$((flags | pu_FLAG_EXIT_ON_CONFLICT))
		;;
		--orgin=* | --resume=*)
			# Split long flags that expect parameters.
			set -- "${arg%%=*}" "${arg#*=}" "$@"
		;;
		-o* | -s*)
			# Split short flags that expect parameters.
			set -- "${arg%%${arg#-?}}" "${arg#-?}" "$@"
		;;
		-? | --*)
			# Complain about broken parameters.
			errors="${errors:+$errors$IFS}$arg Unknown parameter."
		;;
		-*)
			# Split concatenated parameters.
			set - "${arg%%${arg#-?}}" "-${arg#-?}" "$@"
		;;
		'')
			# Ignore empty parameters.
		;;
		*)
			# Explicitely reinstall these.
			pkgPatterns="${pkgPatterns:+$pkgPatterns$IFS}$arg"
		;;
		esac
	done

	#
	# Perform final parameter logic checks that cannot be performed on the
	# fly without enforcing a certain order of parameters.
	#
	# TODO Might become obsolete because of depending packages reinstall
	if [ $((flags & pu_FLAG_RECURSIVE2)) -ne 0 -a $((flags & pu_FLAG_UPWARD_RECURSIVE)) -eq 0 ]; then
		errors="${errors:+$errors$IFS}Thorough recursiveness can only be used in conjunction with upwards recursiveness."
	fi

	#
	# If errors occoured, print them and bail out.
	#
	if [ -n "$errors" ]; then
		echo "$errors" | /usr/bin/sed "s,^,ERROR(ERR_ARG=$pu_ERR_ARG): ," | $pu_terminal.stderr
		pu_errno=$PU_ERR_ARG
		return 1
	fi

	if pu:Session session $flags "$pkgPatterns" "$pkgReplace" $pu_terminal; then
		$session.delete
	fi
}

#
# An instance of this class represents a pkg_upgrade session.
#
# It holds all session information and can be terminated when an error occurs
#
#
bsda:obj:createClass pu:Session \
	implements:bsda:scheduler:Process \
	w:private:signal \
		"Is set to a signal if one was trapped." \
	w:private:flags \
		"The configuration flags." \
	w:private:terminal \
		"The Terminal object for this session." \
	w:private:index \
		"The Index object for this session." \
	w:private:moved \
		"The Moved object for a session." \
	i:private:init \
		"The constructor initializes a session." \
	c:private:clean \
		"The destructor cleans up the session." \
	x:private:setupSignals \
		"Setup signal trapping." \
	x:private:setupTerminal \
		"Updates the terminal to use." \
	x:private:setupLock \
		"Creates an UMA lock." \
	x:private:setupIndex \
		"Updates the index." \
	x:private:error \
		"Outputs an error message and sets pu_errno." \
	x:private:warn \
		"Outputs a warning." \
	x:private:uma \
		"Calls UMA with the given parameters." \

#
# @param 1
#	The flags for this session, a bitfield to read and write with the
#	pu_FLAG_* bits.
# @param 2
#	A list of explicite package matching patterns for install/reinstall.
# @param 3
#	The package replace instructions.
# @param 4
#	The terminal to use.
#
pu:Session.init() {
	$this.setFlags $1
	$this.setupTerminal $4
	$this.setupSignals
	$this.setupLock || return
	$this.setupIndex || return
}

pu:Session.clean() {
	local terminal
	$this.uma unlock
	$this.getTerminal terminal
	$terminal.delete
}

pu:Session.setupSignals() {
	trap "${this}signal=HUP" hup
	trap "${this}signal=INT" int
	trap "${this}signal=TERM" term
	trap - EXIT
}

pu:Session.setupTerminal() {
	local flags
	$this.getFlags flags
	$this.setTerminal $1

	# Turn off all the fancy terminal features if clean output was
	# requested.
	if [ $((flags & pu_FLAG_CLEAN)) -ne 0 ]; then
		$1.deactivate
	fi
}

pu:Session.setupLock() {
	if ! $this.uma lock; then
		local gid
		gid="$(/usr/sbin/pw show user "$USER" | /usr/bin/cut -d: -f4)"
		if [ $gid -ne 0 ]; then
			$this.error $pu_ERR_LOCK "The command requires super user privileges."
		else
			$this.error $pu_ERR_LOCK "The uma (Update MAnager) lock could not be acquired, it appears the package/ports infrastructure is in use or there is make activity from the root user."
		fi
		return 1
	fi
}

pu:Session.setupIndex() {
	local flags index moved
	$this.getFlags flags

	# Check whether a keep index is requested.
	if [ $((flags & pu_FLAG_KEEP_INDEX)) -eq 0 ]; then
		# Try getting a new index.
		if ! $this.uma fetch ftpindex; then
			$this.error $pu_ERR_INDEX "Acquiring an up to date INDEX/MOVED/UPDATING failed."
			return 1
		fi
	else
		# Keeping the index was requested, check whether there is one.
		if [ ! -r "$PKG_INDEX" ]; then
			$this.error $pu_ERR_INDEX "Cannot read INDEX file at '$PKG_INDEX'."
			return 1
		fi
		if [ ! -r "$PKG_MOVED" ]; then
			$this.error $pu_ERR_INDEX "Cannot read MOVED file at '$PKG_MOVED'."
			return 1
		fi
	fi
	bsda:pkg:Moved moved "$PKG_MOVED"
	bsda:pkg:Index index "$PKG_INDEX" $moved
	$this.setMoved $moved
	$this.setIndex $index
}

#
# @param 1
#	The error number as defined in the pu_ERR_* constants.
# @param 2
#	The error message.
#
pu:Session.error() {
	pu_errno=$1
	eval "\$${this}terminal.stderr \"ERROR(\$pu_ERR_str_$1=$1): $2\""
}

#
# Calls UMA with the current PID.
#
# @param @
#	The parameters to pass on to uma.
#
pu:Session.uma() {
	$RUNDIR/uma $bsda_obj_pid "$@"
}

pu_params "$@"
return $pu_errno


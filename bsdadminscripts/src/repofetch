#!/bin/sh -f
#
# Copyright (c) 2010
# Dominic Fandrey <kamikaze@bsdforen.de>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

readonly version=0.2
readonly name=repofetch

# Get the execution path.
rundir="${0%/${0##*/}}"
bsda_dir="%%DATADIR%%"
#HACK
bsda_dir="${0%/${0##*/}}"
#hack

#prefix="%%PREFIX%%"
prefix="/usr/local"

# Include framework for object oriented shell scripting.
. ${bsda_dir:-.}/bsda_obj.sh

# Include downloader library.
. ${bsda_dir:-.}/bsda_download.sh

# Include the terminal library.
. ${bsda_dir:-.}/bsda_tty.sh

# Include scheduler library.
. ${bsda_dir:-.}/bsda_scheduler.sh

readonly rf_ERR_PARAM_COMMAND_UNKNOWN=1
readonly rf_ERR_PARAM_COMMAND_AMBIGUOUS=2
readonly rf_ERR_PARAM_SESSION_UNKNOWN=3
readonly rf_ERR_PARAM_SESSION_CREATE_FAIL=4
readonly rf_ERR_PARAM_SERVERS_FAIL=5
readonly rf_ERR_PARAM_FETCH_DIR_MISSING=6

# Session storage path.
readonly rf_session_dir="$HOME/.repofetch"

#
# Returns whether the requested session exists.
#
# @param rf_session_name
#	The session name.
# @param rf_session_dir
#	The default session location, used when rf_session does not contain
#	path information.
# @param rf_session_file
#	Populates rf_session_file with the appropriate <path>/<filename>.
# @return
#	True (0) if the session exists, else false (1).
rf_session_exists() {
	test -n "$rf_session_name" || return

	rf_session_file="$rf_session_name"
	if [ "$rf_session_name" = "${rf_session_name##*/}" ]; then
		rf_session_file="$rf_session_dir/$rf_session_file"
	fi

	test -e "$rf_session_file"
	return
}

#
# Outputs the session file to stdout.
#
# This is expected to be used for deserializing:
#	bsda:obj:deserialize rf_session "$(rf_session_read)"
#
# The rf_session_exists() function has to be run beforehand!
#
# @param rf_session_file
#	The file containing the session data.
# @return
#	Whatever bunzip2(1) returned.
#
rf_session_read() {
	bsda:obj:deserialize rf_session "$(/usr/bin/lockf -ks "$rf_session_file" /usr/bin/bunzip2 -c "$rf_session_file" 2> /dev/null)"
}

#
# Expects data to write into the session file on stdin.
#
# This is expected to be used for serializing:
#	$rf_session.serialize | rf_session_write
#
# The rf_session_exists() function has to be run beforehand!
#
# @param rf_session_file
#	The file containing the session data.
# @return
#	Whatever bzip2(1) returned.
#
rf_session_write() {
	/bin/mkdir -p "${rf_session_file%/*}"
	$rf_session.serializeDeep | /usr/bin/lockf -ks "$rf_session_file" /usr/bin/bzip2 2> /dev/null > "$rf_session_file"
}

#
# Deletes the session file.
#
# The rf_session_exists() function has to be run beforehand!
#
# @param rf_session_file
#	The session file to delete.
# @return
#	Whatever rm(1) returned.
#
rf_session_delete() {
	/bin/rm "$rf_session_file"
}

#
# Parses parameters to the init command.
#
# To do so, it builds a list of servers and a downloader and feeds them
# to the session object.
#
# @param @
#	The parameters to parse.
# @param rf_terminal
#	The terminal instance to use.
# @param rf_session
#	The session to use.
#
rf_init_params() {
	local IFS arg master mirror mirrors servers manager pkgsites pkgsite

	IFS='
'

	master=
	mirrors=

	while [ $# -gt 0 ]; do
		arg="$1"
		shift

		case "$arg" in
		-L | --uma-latest)
			# Inject the UMA stuff into the parameters.
			eval "$($rundir/uma env)"
			pkgsites="${PACKAGESITE%/*?}/Latest"
			for pkgsite in $PACKAGESITE_MIRRORS; do
				pkgsites="$pkgsites$IFS${pkgsite%/*?}/Latest"
			done
			set -- $pkgsites "$@"
		;;
		-A | --uma-all)
			# Inject the UMA stuff into the parameters.
			eval "$($rundir/uma env)"
			pkgsites="${PACKAGESITE%/*?}/All"
			for pkgsite in $PACKAGESITE_MIRRORS; do
				pkgsites="$pkgsites$IFS${pkgsite%/*?}/All"
			done
			set -- $pkgsites "$@"
		;;
		*)
			bsda:download:Server mirror "$arg"
			if [ -z "$master" ]; then
				master="$mirror"
			else
				mirrors="${mirrors:+$mirrors$IFS}$mirror"
			fi
		;;
		esac
	done

	if [ -z "$master" ]; then
		$rf_terminal.stderr "ERROR: No servers were specified!"
		return $rf_ERR_PARAM_SERVERS_FAIL
	fi
	bsda:download:Servers servers $master $mirrors
	bsda:download:Manager manager $servers
	$rf_session.registerDownloader $manager
}

#
# Creates a new session and writes it to the session file.
#
# @param @
#	All parameters are forwarded to the rf_init_params() function.
# @return
#	rf_ERR_PARAM_SESSION_CREATE_FAIL or true (0)
#
rf_init() {
	if rf_session_exists; then
		$rf_terminal.stderr "ERROR: Creating session '$rf_session_name' failed, because it already exists!"
		return $rf_ERR_PARAM_SESSION_CREATE_FAIL
	fi

	rf:Session rf_session
	rf_init_params "$@" || return
	rf_session_write
	return 0
}

#
# Terminates a session and deletes it.
#
# @result
#	rf_ERR_PARAM_SESSION_UNKNOWN or true (0)
#
rf_term() {
	if ! rf_session_exists; then
		$rf_terminal.stderr "ERROR: The session '$rf_session_name' does not exist!"
		return $rf_ERR_PARAM_SESSION_UNKNOWN
	fi

	rf_session_read
	$rf_session.term
	rf_session_delete
	return 0
}

#
# Parses the parameters to the fetch command.
#
# @param @
#	Takes an arbitrary number of downloads in the following pattern:
#		<remote file> <local file>
# @param rf_terminal
#	The terminal instance to use.
# @param rf_session
#	The session to use.
# @return
#	rf_ERR_PARAM_FETCH_DIR_MISSING or true (0)
#
rf_fetch_params() {
	local IFS arg source targetDir target downloads

	IFS='
'

	targetDir="$(pwd)"
	downloads=

	while [ $# -gt 0 ]; do
		arg="$1"
		shift

		case "$arg" in
		-d | --dir)
			arg="$1"
			shift
			targetDir="$arg"
			# Relative paths are not acceptable, we cannot be
			# certain the download manager is running from the
			# same place.
			if [ -n "${targetDir%%/*}" ]; then
				# Prepend the current path.
				targetDir="$(pwd)/$targetDir"
			fi
			if [ ! -d "$targetDir" ]; then
				$rf_terminal.stderr "ERROR: '$targetDir' is not a directory!"
				return $rf_ERR_PARAM_FETCH_DIR_MISSING
			fi
		;;
		*)
			target="$targetDir/${arg##*/}"
			downloads="${downloads:+$downloads$IFS}$arg$IFS$target"
		;;
		esac
	done

	$rf_session.fetch $downloads
	return 0
}

#
# Requests files from the background downloader.
#
# @param @
#	The parameters to parse, see rf_fetch_params().
# @return
#	rf_ERR_PARAM_FETCH_DIR_MISSING, rf_ERR_PARAM_SESSION_UNKNOWN
#	or true (0)
#
rf_fetch() {
	if ! rf_session_exists; then
		$rf_terminal.stderr "ERROR: The session '$rf_session_name' does not exist!"
		return $rf_ERR_PARAM_SESSION_UNKNOWN
	fi

	rf_session_read
	rf_fetch_params "$@" || return
	rf_session_write
}

#
# Start the session monitor.
#
# @param 1
#	The interval at which to update the display, If this is not a simple
#	integer or floating point number, it is ignored.
#
rf_monitor() {
	local interval

	if ! rf_session_exists; then
		$rf_terminal.stderr "ERROR: The session '$rf_session_name' does not exist!"
		return $rf_ERR_PARAM_SESSION_UNKNOWN
	fi

	rf_session_read
	
	interval=2
	if bsda:obj:isSimpleFloat "$1"; then
		interval="$1"
	fi

	$rf_session.monitor $rf_terminal $interval
}

#
# List sessions in the default session directory.
#
rf_list() {
	/bin/ls "$rf_session_dir"
}

#
# Prints some information about available commands.
#
rf_help() {
	$rf_terminal.stdout "$name v$version
usage:
	$name init <session> <master> [<mirror>] [-L | -A] [<mirror>] [...]
	$name init <session> ((-L | --uma-latest) | (-A | --uma-all)) [<mirror>] [...]
	$name term <session>
	$name fetch <session> [(-d | --dir) <target path>] <file> [...]
	$name monitor <session> [<interval>]
	$name list
	$name help"
}

#
# Instances of this class represent a download session.
#
bsda:obj:createClass rf:Session \
	w:private:downloader \
		"The download manager instance." \
	w:private:monitoring \
		"Can be reset from a trap to deactivate the monitor." \
	x:public:registerDownloader \
		"Initial download manager registration." \
	x:public:term \
		"Stop the download manager." \
	x:public:fetch \
		"Fetch something." \
	x:public:monitor \
		"Show what's going on." \

#
# Registers the download manager to the class.
#
# @param 1
#	The download manager to register.
# @return
#	0 registering the download manager succeeded
#	1 a download manager was already registered
#	2 the given parameter is not a download manager
#
rf:Session.registerDownloader() {
	local downloader
	$this.getDownloader downloader

	if [ -n "$downloader" ]; then
		# Really, there's only one download manager per session.
		return 1
	fi

	if ! bsda:download:Manager.isInstance "$1"; then
		# Not a download manager? Bail out.
		return 2
	fi
	$this.setDownloader "$1"
	return 0
}

#
# Terminates the download manager process.
#
# @return
#	0 the background downloader was terminated
#	1 no background downloader registered
#
rf:Session.term() {
	local downloader
	$this.getDownloader downloader

	if ! bsda:download:Manager.isInstance "$downloader"; then
		# Download manager not set WTF?
		return 1
	fi

	$downloader.term
	return 0
}

#
# Dispatches download requests to the background downloader.
#
# @param @
#	Takes an arbitrary number of downloads in the following pattern:
#		<remote file> <local file>
# @result
#	0 all downloads dispatched
#	1 no background downloader registered
#
rf:Session.fetch() {
	local IFS downloader downloads job

	IFS='
'
	$this.getDownloader downloader

	if ! bsda:download:Manager.isInstance "$downloader"; then
		# Download manager not set WTF?
		return 1
	fi

	$downloader.createJobs downloads "$@"
	# The download jobs are not really required in this context.
	for job in $downloads; do
		$job.delete
	done
	return 0
}

#
# Continuously display information about the background downloader.
#
# This terminates graciously upon receiving sigint, sigkill or if the
# download manager terminates.
#
# @param 1
#	The terminal object to use.
# @param 2
#	The interval to update information.
# 
rf:Session.monitor() {
	local terminal sleep downloader jobsActive plural
	local serversCount jobs job line null file progress speed unit
	local size full speedSum displayJob

	terminal="$1"

	# Setup sleeper.
	bsda:scheduler:Sleep sleep "$2"

	# Setup monitor running flag.
	$this.setMonitoring 1

	# Allow clean termination.
	trap "unset ${this}monitoring" sigint sigkill

	$this.getDownloader downloader

	# Start monitoring loop.
	$terminal.use 2
	displayJob=
	while $downloader.isActive && [ -n "$($this.getMonitoring)" ]; do
		# Synchronize with the manager.
		$downloader.run
		# Get a summary from the servers.
		$downloader.getStatus jobsActive null serversCount jobs

		# Accumulate speed of all downloads in progress.
		speedSum=0
		displayJob="$(echo "$jobs" | grep -Fx "$displayJob")"
		for job in $jobs; do
			# Pick one job to be displayed.
			if [ -z "$displayJob" ]; then
				displayJob=$job
			fi
			$job.getStatus null null null null null null speed
			speedSum=$((speedSum + speed))
		done
		$terminal.convertBytes speedSum unit "$speedSum" 4
		speedSum="$speedSum ${unit}b/s"

		# Display one job's progress. Displaying them all gets too
		# annoying.
		line=
		if [ -n "$displayJob" ]; then
			$displayJob.getStatus file size full null null progress speed
			$terminal.convertBytes speed unit "$speed" 4
			speed="$speed ${unit}b/s"
			$terminal.convertBytes full unit "$full" 4
			full="$full ${unit}b"
			$terminal.convertBytesToUnit size "$unit" "$size" 4
			$terminal.format line '<-x-:s> <4:s> of <:s> (<3:d>%%) at <9:s>' "${file##*/}" "$size" "$full" "$progress" "$speed"
		fi
		$terminal.line 1 "$line"

		# show the summary.
		plural=
		test $jobsActive -ne 1 && plural=s
		$terminal.format line "Downloading <${#serversCount}:d> file<-x:s> at <9:s>" "$jobsActive" "s" "$speedSum"
		$terminal.line 0 "$line"

		# Get the completed jobs, display them and forget them.
		$downloader.completedJobs jobs
		for job in $jobs; do
			# Output the completed job.
			$job.getTarget file
			if $job.hasSucceeded; then
				$terminal.stdout "DONE: $file"
			else
				$terminal.stdout "FAIL: $file"
			fi
			# Because completed jobs are deleted, they should
			# better not be displayed.
			if [ "$job" = "$displayJob" ]; then
				displayJob=
			fi
			# Forget about the job.
			$job.delete
		done
		$sleep.run
	done
}

# Create a terminal object for this session.
bsda:tty:Terminal rf_terminal
# Make sure the terminal is in order, when the program exits.
trap "$rf_terminal.delete" EXIT

# List of available session commands.
readonly rf_session_commands="init
term
fetch
monitor
list
help"

#
# Here we go, the first parameter always represents the command.
# The second parameter represents the session.
#

# Any command that unambiguously begins like an existing command is accepted.
rf_session_name="$2"
rf_command="$(echo "$rf_session_commands" | grep "^$1")"

if ! echo "$rf_command" | /usr/bin/grep -qxF "$rf_session_commands"; then
	$rf_terminal.stderr "ERROR: '$1' is not a valid command."
	return $rf_ERR_PARAM_COMMAND_UNKNOWN
fi
if [ $(($(echo "$rf_command" | /usr/bin/wc -l))) -gt 1 ]; then
	$rf_terminal.stderr "ERROR: '$1' is an ambiguous command, matching:
$rf_command"
	return $rf_ERR_PARAM_COMMAND_AMBIGUOUS
fi
shift 2

# Execute the given command.
rf_$rf_command "$@"

